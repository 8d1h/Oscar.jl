<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Groups Â· Oscar.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Oscar.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Welcome to Oscar</a></li><li><span class="tocitem">Rings</span><ul><li><a class="tocitem" href="../../AbstractAlgebra/docs/src/rings/">Ring Interface</a></li><li><a class="tocitem" href="../../Rings/integer/">Integers</a></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Univariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AbstractAlgebra/docs/src/polynomial_rings/">Univariate Polynomial Ring Interface</a></li><li><a class="tocitem" href="../../AbstractAlgebra/docs/src/polynomial/">Generic univariate polynomials</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Multivariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AbstractAlgebra/docs/src/mpolynomial_rings/">Multivariate Polynomial Ring Interface</a></li><li><a class="tocitem" href="../../AbstractAlgebra/docs/src/mpolynomial/">Generic sparse distributed multivariate polynomials</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-5" type="checkbox"/><label class="tocitem" for="menuitem-2-5"><span class="docs-label">Orders</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/docs/src/orders/introduction/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/docs/src/orders/orders/">Orders</a></li><li><a class="tocitem" href="../../Hecke/docs/src/orders/elements/">Elements</a></li><li><a class="tocitem" href="../../Hecke/docs/src/orders/ideals/">Ideals</a></li><li><a class="tocitem" href="../../Hecke/docs/src/orders/frac_ideals/">Fractional ideals</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-6" type="checkbox"/><label class="tocitem" for="menuitem-2-6"><span class="docs-label">Series Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AbstractAlgebra/docs/src/series_rings/">Series Ring Interface</a></li><li><a class="tocitem" href="../../AbstractAlgebra/docs/src/series/">Generic power series</a></li><li><a class="tocitem" href="../../AbstractAlgebra/docs/src/puiseux/">Generic Puiseux series</a></li><li><a class="tocitem" href="../../Nemo/docs/src/series/">Power series and Laurent series</a></li><li><a class="tocitem" href="../../Nemo/docs/src/puiseux/">Puiseux series</a></li></ul></li></ul></li><li><span class="tocitem">Fields</span><ul><li><a class="tocitem" href="../../AbstractAlgebra/docs/src/fields/">Field Interface</a></li><li><a class="tocitem" href="../../Rings/rational/">Rationals</a></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Number Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/docs/src/number_fields/intro/">Number Fields</a></li><li><a class="tocitem" href="../../Hecke/docs/src/number_fields/basics/">-</a></li><li><a class="tocitem" href="../../Hecke/docs/src/number_fields/elements/">-</a></li></ul></li><li><a class="tocitem" href="../../Hecke/docs/src/FacElem/">Factored Elements</a></li><li><a class="tocitem" href="../../Hecke/docs/src/class_fields/intro/">Class Field Theory</a></li><li><a class="tocitem" href="../../AbstractAlgebra/docs/src/fields/">Field Interface</a></li><li><a class="tocitem" href="../../AbstractAlgebra/docs/src/fraction_fields/">Fraction Field Interface</a></li><li><a class="tocitem" href="../../AbstractAlgebra/docs/src/fraction/">Generic fraction fields</a></li><li><input class="collapse-toggle" id="menuitem-3-9" type="checkbox"/><label class="tocitem" for="menuitem-3-9"><span class="docs-label">Local Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Nemo/docs/src/padic/">Padics</a></li><li><a class="tocitem" href="../../Nemo/docs/src/qadic/">Qadics</a></li></ul></li><li><a class="tocitem" href="../../Nemo/docs/src/finitefield/">Finite fields</a></li></ul></li><li><span class="tocitem">Groups</span><ul><li class="is-active"><a class="tocitem" href>Groups</a><ul class="internal"><li><a class="tocitem" href="#Basics"><span>Basics</span></a></li><li><a class="tocitem" href="#subgroups"><span>Subgroups</span></a></li><li><a class="tocitem" href="#quotient"><span>Quotients</span></a></li><li><a class="tocitem" href="#Products-of-groups"><span>Products of groups</span></a></li><li><a class="tocitem" href="#Permutation-groups"><span>Permutation groups</span></a></li><li><a class="tocitem" href="#Finitely-presented-groups"><span>Finitely presented groups</span></a></li><li><a class="tocitem" href="#Polycyclic-groups"><span>Polycyclic groups</span></a></li><li><a class="tocitem" href="#Matrix-groups"><span>Matrix groups</span></a></li><li><a class="tocitem" href="#Group-homomorphisms"><span>Group homomorphisms</span></a></li><li><a class="tocitem" href="#Groups-of-automorphisms"><span>Groups of automorphisms</span></a></li><li><a class="tocitem" href="#Group-libraries"><span>Group libraries</span></a></li></ul></li><li><a class="tocitem" href="../../Hecke/docs/src/abelian/introduction/">Abelian Groups</a></li></ul></li><li><span class="tocitem">Linear Algebra</span><ul><li><a class="tocitem" href="../../Hecke/docs/src/sparse/intro/">Sparse linear algebra</a></li><li><a class="tocitem" href="../../AbstractAlgebra/docs/src/matrix_spaces/">Matrix Interface</a></li><li><a class="tocitem" href="../../AbstractAlgebra/docs/src/matrix/">Generic matrices</a></li><li><a class="tocitem" href="../../AbstractAlgebra/docs/src/matrix_algebras/">Generic matrix algebras</a></li><li><input class="collapse-toggle" id="menuitem-5-5" type="checkbox"/><label class="tocitem" for="menuitem-5-5"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AbstractAlgebra/docs/src/module/">Module Interface</a></li><li><a class="tocitem" href="../../AbstractAlgebra/docs/src/free_module/">Free Modules and Vector Spaces</a></li><li><a class="tocitem" href="../../AbstractAlgebra/docs/src/submodule/">Submodules</a></li><li><a class="tocitem" href="../../AbstractAlgebra/docs/src/quotient_module/">Quotient modules</a></li><li><a class="tocitem" href="../../AbstractAlgebra/docs/src/direct_sum/">Direct Sums</a></li><li><a class="tocitem" href="../../AbstractAlgebra/docs/src/module_homomorphism/">Module Homomorphisms</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-6" type="checkbox"/><label class="tocitem" for="menuitem-5-6"><span class="docs-label">Quadratic and Hermitian forms</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/docs/src/quad_forms/introduction/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/docs/src/quad_forms/basics/">Basics</a></li><li><a class="tocitem" href="../../Hecke/docs/src/quad_forms/lattices/">Quadratic and hermitian lattices</a></li></ul></li></ul></li><li><span class="tocitem">Commutative Algebra</span><ul><li><a class="tocitem" href="../../CommutativeAlgebra/ca/">Introduction</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ca_rings/">Polynomial Rings</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ca_ideals/">Ideals in Polynomial Rings</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ca_modules/">Modules Over Polynomial Rings</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ca_quotient_rings/">Quotient Rings of Polynomial Rings</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ca_affine_algebras/">Affine Algebras</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ca_binomial_ideals/">Binomial Primary Decomposition</a></li><li><a class="tocitem" href="../../CommutativeAlgebra/ca_invariant_theory/">Invariant Theory</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Groups</a></li><li class="is-active"><a href>Groups</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Groups</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/oscar-system/Oscar.jl/blob/master/docs/src/Groups/groups.md" title="Edit on GitHub"><span class="docs-icon fab">ï</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><ul><li><a href="#Groups">Groups</a></li><ul><li><a href="#Basics">Basics</a></li><li><a href="#subgroups">Subgroups</a></li><li><a href="#quotient">Quotients</a></li><li><a href="#Products-of-groups">Products of groups</a></li><li><a href="#Permutation-groups">Permutation groups</a></li><li><a href="#Finitely-presented-groups">Finitely presented groups</a></li><li><a href="#Polycyclic-groups">Polycyclic groups</a></li><li><a href="#Matrix-groups">Matrix groups</a></li><li><a href="#Group-homomorphisms">Group homomorphisms</a></li><li><a href="#Groups-of-automorphisms">Groups of automorphisms</a></li><li><a href="#Group-libraries">Group libraries</a></li></ul></ul><h1 id="Groups"><a class="docs-heading-anchor" href="#Groups">Groups</a><a id="Groups-1"></a><a class="docs-heading-anchor-permalink" href="#Groups" title="Permalink"></a></h1><p>Oscar supports the following types of groups:</p><ul><li><code>PermGroup</code> = groups of permutations</li><li><code>MatrixGroup</code> = groups of matrices</li><li><code>FPGroup</code> = finitely presented groups</li><li><code>PcGroup</code> = polycyclic groups</li><li><code>DirectProductOfGroups</code> = direct product of two groups</li><li><code>AutomorphismGroup</code> = group of automorphisms over a group</li></ul><p>If <code>x</code> is an element of the group <code>G</code> of type <code>T</code>, then the type of <code>x</code> is <code>GAPGroupElement{T}</code>.</p><h2 id="Basics"><a class="docs-heading-anchor" href="#Basics">Basics</a><a id="Basics-1"></a><a class="docs-heading-anchor-permalink" href="#Basics" title="Permalink"></a></h2><h3 id="elements_of_groups"><a class="docs-heading-anchor" href="#elements_of_groups">Elements of groups</a><a id="elements_of_groups-1"></a><a class="docs-heading-anchor-permalink" href="#elements_of_groups" title="Permalink"></a></h3><p>Given a group <code>G</code>, it is always possible to have access to some particular elements.</p><article class="docstring"><header><a class="docstring-binding" id="GAPGroup" href="#GAPGroup"><code>GAPGroup</code></a> â <span class="docstring-category">Type</span></header><section><div><p>TODO: document this</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/types.jl#L72-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BasicGAPGroupElem" href="#BasicGAPGroupElem"><code>BasicGAPGroupElem</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BasicGAPGroupElem{T&lt;:GAPGroup}</code></pre><p>The type <code>BasicGAPGroupElem</code> gathers all types of group elements described only by an underlying GAP object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/types.jl#L78-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="elem_type-Union{Tuple{Type{T}}, Tuple{T}} where T" href="#elem_type-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>elem_type</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">elem_type(parent)
elem_type(parent_type)</code></pre><p>Given a parent object (or its type), return the type of its elements.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; S, x = PowerSeriesRing(QQ, 2, &quot;x&quot;)
(Univariate power series ring in x over Rationals, x + O(x^3))

julia&gt; elem_type(S) == typeof(x)
true</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="one-Tuple{Oscar.GAPGroup}" href="#one-Tuple{Oscar.GAPGroup}"><code>one</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">one(G::Group) -&gt; x::GAPGroupElem{typeof(G)}</code></pre><p>Return the identity of the group <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/GAPGroups.jl#L185-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="one-Tuple{GAPGroupElem}" href="#one-Tuple{GAPGroupElem}"><code>one</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">one(x::GAPGroupElement{T}) -&gt; x::GAPGroupElem{T}</code></pre><p>Return the identity of the parent group of x.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/GAPGroups.jl#L192-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="gens-Tuple{Oscar.GAPGroup}" href="#gens-Tuple{Oscar.GAPGroup}"><code>gens</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gens(G::Group)</code></pre><p>Return an array of generators of the group <code>G</code>. To get a specific generator, use <code>G[i]</code> or <code>gen(G,i)</code> instead of <code>gens(G)[i]</code>, as that is more efficient.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/GAPGroups.jl#L371-L376">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ngens-Tuple{Oscar.GAPGroup}" href="#ngens-Tuple{Oscar.GAPGroup}"><code>ngens</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ngens(G::Group) -&gt; Int</code></pre><p>Return the length of the array gens(G).</p><div class="admonition is-warning"><header class="admonition-header">WARNING:</header><div class="admonition-body"><p>this is <em>NOT</em>, in general, the minimum number of generators for G.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/GAPGroups.jl#L398-L405">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="gen-Tuple{Oscar.GAPGroup,Int64}" href="#gen-Tuple{Oscar.GAPGroup,Int64}"><code>gen</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gen(G::Group, i::Integer)</code></pre><p>Return the <code>i</code>-th element of the array gens(<code>G</code>). This is equivalent to <code>G[i]</code>, and returns <code>gens(G)[i]</code> but may be more efficient than the latter. If <code>i</code> is greater than the length of gens(<code>G</code>), an ERROR is thrown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/GAPGroups.jl#L386-L390">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="rand-Tuple{Oscar.GAPGroup}" href="#rand-Tuple{Oscar.GAPGroup}"><code>rand</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rand(G::Group)</code></pre><p>Return a random element of the group <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/GAPGroups.jl#L124-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="rand_pseudo-Tuple{Oscar.GAPGroup}" href="#rand_pseudo-Tuple{Oscar.GAPGroup}"><code>rand_pseudo</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rand_pseudo(G::Group)</code></pre><p>Return a random element of the group <code>G</code>. It works faster than <code>rand</code>, but the elements are not necessarily equally distributed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/GAPGroups.jl#L134-L138">source</a></section></article><p>It is also possible to obtain the generators of <code>G</code> by typing</p><pre><code class="language-julia">f1,f2,f3 = gens(G)</code></pre><p>This is equivalent to</p><pre><code class="language-julia">f1=G[1]; f2=G[2]; f3=G[3];</code></pre><p>If the group <code>G</code> has been created as the subgroup of another group generated by a list of elements <code>L</code>, then the generating set returned by the function <code>gens</code> corresponds to <code>L</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The output of <code>gens(G)</code> is not, in general, the minimal list of generators for <code>G</code>.</p></div></div><h3 id="Operations"><a class="docs-heading-anchor" href="#Operations">Operations</a><a id="Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Operations" title="Permalink"></a></h3><p>Oscar supports the following operations and functions on group elements.</p><ul><li><code>*</code> = multiplication between two elements in a group.</li><li><code>inv(x)</code> = <span>$x^{-1}$</span> the inverse of <code>x</code>.</li><li><code>x/y</code> = the element <span>$xy^{-1}$</span>.</li><li><code>x^n</code> = the <span>$n$</span>-th power of <code>x</code>. If <span>$n = 0$</span>, the identity of the group is returned; if <span>$n &lt; 0$</span>, the <span>$-n$</span>-th power of the inverse of <code>x</code> is returned.</li><li><code>isone(x)</code>: returns whether <code>x</code> is the identity of the group.</li><li><code>conj(x,y)</code> = <code>x^y</code> = the conjugate of <code>x</code> by <code>y</code>, i.e. the element <span>$y^{-1}xy$</span>.</li><li><code>comm(x,y)</code> = the commutator of <code>x</code> and <code>y</code>, i.e. the element <span>$x^{-1}y^{-1}xy$</span>.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In Oscar, the expression <code>x^y^z</code> is equivalent to <code>x^(y^z)</code>. In other words, conjugations are evaluated from the right to the left.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="comm-Tuple{GAPGroupElem,GAPGroupElem}" href="#comm-Tuple{GAPGroupElem,GAPGroupElem}"><code>comm</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">comm(x::GAPGroupElem, y::GAPGroupElem)</code></pre><p>Return <code>[x,y]</code> = <code>x^-1*y^-1*x*y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/GAPGroups.jl#L228-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="nilpotency_class-Tuple{Oscar.GAPGroup}" href="#nilpotency_class-Tuple{Oscar.GAPGroup}"><code>nilpotency_class</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nilpotency_class(G::GAPGroup)</code></pre><p>Return the nilpotency class of <code>G</code>, that is the smallest integer <code>d</code> such that <code>G</code> has a central series of length <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/GAPGroups.jl#L840-L844">source</a></section></article><h3 id="Properties-of-groups"><a class="docs-heading-anchor" href="#Properties-of-groups">Properties of groups</a><a id="Properties-of-groups-1"></a><a class="docs-heading-anchor-permalink" href="#Properties-of-groups" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="isabelian" href="#isabelian"><code>isabelian</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isabelian(G::GrpGen) -&gt; Bool</code></pre><p>Returns whether <span>$G$</span> is abelian.</p></div></section><section><div><pre><code class="language-none">isabelian(K::NfRel) -&gt; Bool</code></pre><p>Check if the extension is abelian over the coefficient ring. The function is probabilistic.</p></div></section><section><div><pre><code class="language-none">isabelian(G::Group)</code></pre><p>Return whether <code>G</code> is abelian.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/group_constructors.jl#L120-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ispgroup" href="#ispgroup"><code>ispgroup</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ispgroup(G)</code></pre><p>Return (<span>$true$</span>,nothing) if <code>G</code> is the trivial group, (<span>$true$</span>,<span>$p$</span>) if |<code>G</code>| is a non-trivial <span>$p$</span>-power, (<span>$false$</span>,nothing) otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/GAPGroups.jl#L812-L816">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="isnilpotent" href="#isnilpotent"><code>isnilpotent</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isnilpotent(G::GAPGroup)</code></pre><p>Return whether the <code>G</code> is nilpotent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/sub.jl#L261-L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="issupersolvable" href="#issupersolvable"><code>issupersolvable</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">issupersolvable(G::GAPGroup)</code></pre><p>Return whether the <code>G</code> is supersolvable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/sub.jl#L270-L274">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="issolvable" href="#issolvable"><code>issolvable</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">issolvable(G::GAPGroup)</code></pre><p>Return whether the <code>G</code> is solvable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/sub.jl#L252-L256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="isperfect" href="#isperfect"><code>isperfect</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isperfect(G)</code></pre><p>Return whether <code>G</code> is a perfect group, i.e., equal to its derived subgroup.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/GAPGroups.jl#L791-L795">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="issimple" href="#issimple"><code>issimple</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">issimple(L::NumField) -&gt; Bool</code></pre><p>Given a number field <span>$L/K$</span> this function returns whether <span>$L$</span> is simple, that is, whether <span>$L/K$</span> is defined by a univariate polynomial$.</p></div></section><section><div><pre><code class="language-none">issimple(G)</code></pre><p>Return whether <code>G</code> is a simple group, i.e., it has not non-trivial normal subgroups.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/GAPGroups.jl#L798-L802">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="isalmostsimple" href="#isalmostsimple"><code>isalmostsimple</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isalmostsimple(G)</code></pre><p>Return whether <code>G</code> is an almost simple group, i.e., if <code>S</code> &lt; <code>G</code> &lt; <code>Aut(S)</code> for some non-abelian simple group <code>S</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/GAPGroups.jl#L805-L809">source</a></section></article><h3 id="Attributes-of-groups"><a class="docs-heading-anchor" href="#Attributes-of-groups">Attributes of groups</a><a id="Attributes-of-groups-1"></a><a class="docs-heading-anchor-permalink" href="#Attributes-of-groups" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="exponent-Tuple{Oscar.GAPGroup}" href="#exponent-Tuple{Oscar.GAPGroup}"><code>exponent</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">exponent(G::Group)</code></pre><p>Return the exponent of <code>G</code>, i.e. the smallest positive integer <code>e</code> such that <code>g</code>^<code>e</code>=1 for every <code>g</code> in <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/GAPGroups.jl#L117-L121">source</a></section></article><h2 id="subgroups"><a class="docs-heading-anchor" href="#subgroups">Subgroups</a><a id="subgroups-1"></a><a class="docs-heading-anchor-permalink" href="#subgroups" title="Permalink"></a></h2><p>The subgroup of a group <code>G</code> generated by the elements <code>x,y,...</code> is defined by the following instruction:</p><ul><li><code>sub(G, [x,y,...])</code> ;</li><li><code>sub(x,y,...)</code>.</li></ul><p>This function returns two objects: a group <code>H</code>, that is the subgroup of <code>G</code> generated by the elements <code>x,y,...</code>, and the embedding homomorphism of <code>H</code> into <code>G</code>. The object <code>H</code> has the same type of <code>G</code>, and it has no memory of the &quot;parent&quot; group <code>G</code>: it is an independent group.</p><p><strong>Examples:</strong></p><pre><code class="language-julia-repl">julia&gt; G = symmetric_group(4); H = sub(G,[cperm([1,2,3]),cperm([2,3,4])]);

julia&gt; H[1] == alternating_group(4)
true</code></pre><p>The following functions are available in Oscar for subgroup properties:</p><article class="docstring"><header><a class="docstring-binding" id="issubgroup" href="#issubgroup"><code>issubgroup</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">issubgroup(G::T, H::T) where T &lt;: GAPGroup</code></pre><p>Return (<code>true</code>,<code>f</code>) if <code>H</code> is a subgroup of <code>G</code>, where <code>f</code> is the embedding homomorphism of <code>H</code> into <code>G</code>, otherwise return (<code>false</code>,<code>nothing</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/sub.jl#L67-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="embedding-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Oscar.GAPGroup" href="#embedding-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Oscar.GAPGroup"><code>embedding</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">embedding(G::T, H::T) where T &lt;: GAPGroup</code></pre><p>Return the embedding morphism of <code>H</code> into <code>G</code>. It throws ERROR if <code>H</code> is not a subgroup of <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/sub.jl#L80-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="index-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Oscar.GAPGroup" href="#index-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Oscar.GAPGroup"><code>index</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">index(G::T, H::T) where T &lt;: GAPGroup</code></pre><p>Return the index of <code>H</code> in <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/sub.jl#L107-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="isnormal-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Oscar.GAPGroup" href="#isnormal-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Oscar.GAPGroup"><code>isnormal</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isnormal(G::T, H::T) where T &lt;: GAPGroup</code></pre><p>Return whether the subgroup <code>H</code> is normal in <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/sub.jl#L234-L238">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ischaracteristic-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Oscar.GAPGroup" href="#ischaracteristic-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Oscar.GAPGroup"><code>ischaracteristic</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ischaracteristic(G::T, H::T) where T &lt;: GAPGroup</code></pre><p>Return whether the subgroup <code>H</code> is characteristic in <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/sub.jl#L243-L247">source</a></section></article><h3 id="Standard-subgroups"><a class="docs-heading-anchor" href="#Standard-subgroups">Standard subgroups</a><a id="Standard-subgroups-1"></a><a class="docs-heading-anchor-permalink" href="#Standard-subgroups" title="Permalink"></a></h3><p>The following functions are available in Oscar to obtain standard subgroups of a group <code>G</code>. Every such function returns a tuple <code>(H,f)</code>, where <code>H</code> is a group of the same type of <code>G</code> and <code>f</code> is the embedding homomorphism of <code>H</code> into <code>G</code>.</p><article class="docstring"><header><a class="docstring-binding" id="trivial_subgroup" href="#trivial_subgroup"><code>trivial_subgroup</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">trivial_subgroup(G::GAPGroup)</code></pre><p>Return the trivial subgroup of <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/sub.jl#L94-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="centre" href="#centre"><code>centre</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">centre(G::Group)</code></pre><p>Return the centre of <code>G</code>, i.e. the subgroup of all <code>x</code> in <code>G</code> such that <code>xy</code>=<code>yx</code> for every <code>y</code> in <code>G</code>, together with its embedding morphism into <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/sub.jl#L196-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="sylow_subgroup-Tuple{Oscar.GAPGroup,Int64}" href="#sylow_subgroup-Tuple{Oscar.GAPGroup,Int64}"><code>sylow_subgroup</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sylow_subgroup(G::Group, p::Int64)</code></pre><p>Return a Sylow <code>p</code>-subgroup of <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/GAPGroups.jl#L726-L730">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="hall_subgroup-Tuple{Oscar.GAPGroup,AbstractArray{var&quot;#s283&quot;,1} where var&quot;#s283&quot;&lt;:Integer}" href="#hall_subgroup-Tuple{Oscar.GAPGroup,AbstractArray{var&quot;#s283&quot;,1} where var&quot;#s283&quot;&lt;:Integer}"><code>hall_subgroup</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hall_subgroup(G::Group, P::Array{Int64})</code></pre><p>Return a Hall <code>P</code>-subgroup of <code>G</code>. It works only if <code>G</code> is solvable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/GAPGroups.jl#L738-L742">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="derived_subgroup" href="#derived_subgroup"><code>derived_subgroup</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">derived_subgroup(G::GAPGroup)</code></pre><p>Return the derived subgroup of <code>G</code>, i.e. the subgroup generated by all commutators of <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/sub.jl#L338-L342">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="fitting_subgroup-Tuple{Oscar.GAPGroup}" href="#fitting_subgroup-Tuple{Oscar.GAPGroup}"><code>fitting_subgroup</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fitting_subgroup(G::GAPGroup)</code></pre><p>Return the Fitting subgroup of <code>G</code>, the largest nilpotent normal subgroup of <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/GAPGroups.jl#L691-L695">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="frattini_subgroup-Tuple{Oscar.GAPGroup}" href="#frattini_subgroup-Tuple{Oscar.GAPGroup}"><code>frattini_subgroup</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">frattini_subgroup(G::GAPGroup)</code></pre><p>Return the Frattini subgroup of <code>G</code>, the intersection of all maximal subgroups of <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/GAPGroups.jl#L698-L702">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="radical_subgroup-Tuple{Oscar.GAPGroup}" href="#radical_subgroup-Tuple{Oscar.GAPGroup}"><code>radical_subgroup</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">radical_subgroup(G::GAPGroup)</code></pre><p>Return the radical subgroup of <code>G</code>, the largest solvable normal subgroup of <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/GAPGroups.jl#L705-L709">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="socle-Tuple{Oscar.GAPGroup}" href="#socle-Tuple{Oscar.GAPGroup}"><code>socle</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">socle(G::GAPGroup)</code></pre><p>Return the socle of <code>G</code>, the subgroup generated by all minimal normal subgroups of <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/GAPGroups.jl#L712-L716">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="pcore-Tuple{Oscar.GAPGroup,Int64}" href="#pcore-Tuple{Oscar.GAPGroup,Int64}"><code>pcore</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pcore(G::Group, p::Int64)</code></pre><p>Return <code>C,f</code>, where <code>C</code> is the <code>p</code>-core (i.e. the largest normal <code>p</code>-subgroup) of <code>G</code> and <code>f</code> is the embedding morphism of <code>C</code> into <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/GAPGroups.jl#L668-L672">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="intersect-Union{Tuple{Vararg{T,N} where N}, Tuple{T}} where T&lt;:Oscar.GAPGroup" href="#intersect-Union{Tuple{Vararg{T,N} where N}, Tuple{T}} where T&lt;:Oscar.GAPGroup"><code>intersect</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">intersect(V::T...) where T &lt;: Group
intersect(V::AbstractVector{T}) where T &lt;: Group</code></pre><p>If <code>V</code> = [<code>G_1</code>, ... , <code>G_n</code>], return the group intersection <code>K</code> of the groups <code>G_1</code>, ..., <code>G_n</code>, together with the embeddings <code>K</code> -&gt; <code>G_i</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/sub.jl#L364-L369">source</a></section></article><p>The following functions return a list of subgroups.</p><article class="docstring"><header><a class="docstring-binding" id="subgroups-Tuple{Oscar.GAPGroup}" href="#subgroups-Tuple{Oscar.GAPGroup}"><code>subgroups</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">subgroups(G::Group)</code></pre><p>Return the list of subgroups of <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/sub.jl#L142-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="normal_subgroups" href="#normal_subgroups"><code>normal_subgroups</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">normal_subgroups(G::Group)</code></pre><p>Return the list of normal subgroups of <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/sub.jl#L133-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="maximal_subgroups" href="#maximal_subgroups"><code>maximal_subgroups</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">maximal_subgroups(G::Group)</code></pre><p>Return the list of maximal subgroups of <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/sub.jl#L151-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="maximal_normal_subgroups" href="#maximal_normal_subgroups"><code>maximal_normal_subgroups</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">maximal_normal_subgroups(G::Group)</code></pre><p>Return the list of maximal normal subgroups of <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/sub.jl#L160-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="minimal_normal_subgroups" href="#minimal_normal_subgroups"><code>minimal_normal_subgroups</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">minimal_normal_subgroups(G::Group)</code></pre><p>Return the list of minimal normal subgroups of <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/sub.jl#L169-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="characteristic_subgroups" href="#characteristic_subgroups"><code>characteristic_subgroups</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">characteristic_subgroups(G::Group)</code></pre><p>Return the list of characteristic subgroups of <code>G</code>, i.e. the subgroups that are invariant under all automorphisms of <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/sub.jl#L178-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="derived_series" href="#derived_series"><code>derived_series</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">derived_series(G::GAPGroup)</code></pre><p>Return the list [<code>G_1</code>, <code>G_2</code>, <code>G_3</code>, ... ], where <code>G_1</code>=<code>G</code> and <code>G_{i+1}</code> = <code>derived_subgroup(G_i)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/sub.jl#L348-L352">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="sylow_system" href="#sylow_system"><code>sylow_system</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sylow_system(G::Group)</code></pre><p>Return an array of Sylow <span>$p$</span>-subgroups of <code>G</code>, where <span>$p$</span> runs over the prime factors of |<code>G</code>|, such that every two such subgroups commute each other (as subgroups). It works only if <code>G</code> is solvable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/GAPGroups.jl#L754-L758">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="hall_system" href="#hall_system"><code>hall_system</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">hall_system(G::Group)</code></pre><p>Return an array of <span>$P$</span>-Hall subgroups of <code>G</code>, where <span>$P$</span> runs over the subsets of prime factors of |<code>G</code>|. It works only if <code>G</code> is solvable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/GAPGroups.jl#L774-L778">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="complement_system" href="#complement_system"><code>complement_system</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">complement_system(G::Group)</code></pre><p>Return an array of <span>$p&#39;$</span>-Hall subgroups of <code>G</code>, where <span>$p$</span> runs over the prime factors of |<code>G</code>|. It works only if <code>G</code> is solvable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/GAPGroups.jl#L764-L768">source</a></section></article><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>When a function returns a list of subgroups, the output consists in the subgroups only; the embeddings are not returned as well. To get the embedding homomorphism of the subgroup <code>H</code> in <code>G</code>, one has to type <code>embedding(G,H)</code></p></div></div><h3 id="Conjugation-action-of-elements-and-subgroups"><a class="docs-heading-anchor" href="#Conjugation-action-of-elements-and-subgroups">Conjugation action of elements and subgroups</a><a id="Conjugation-action-of-elements-and-subgroups-1"></a><a class="docs-heading-anchor-permalink" href="#Conjugation-action-of-elements-and-subgroups" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="isconjugate-Tuple{Oscar.GAPGroup,GAPGroupElem,GAPGroupElem}" href="#isconjugate-Tuple{Oscar.GAPGroup,GAPGroupElem,GAPGroupElem}"><code>isconjugate</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isconjugate(G::GAPGroup, x::GAPGroupElem, y::GAPGroupElem)</code></pre><p>Return whether <code>x</code> and <code>y</code> are conjugate elements in <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/GAPGroups.jl#L505-L509">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="isconjugate-Tuple{Oscar.GAPGroup,Oscar.GAPGroup,Oscar.GAPGroup}" href="#isconjugate-Tuple{Oscar.GAPGroup,Oscar.GAPGroup,Oscar.GAPGroup}"><code>isconjugate</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isconjugate(G::GAPGroup, H::GAPGroup, K::GAPGroup)</code></pre><p>Return whether <code>H</code> and <code>K</code> are conjugate subgroups in <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/GAPGroups.jl#L574-L578">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="representative_action-Tuple{Oscar.GAPGroup,GAPGroupElem,GAPGroupElem}" href="#representative_action-Tuple{Oscar.GAPGroup,GAPGroupElem,GAPGroupElem}"><code>representative_action</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">representative_action(G::Group, x::GAPGroupElem, y::GAPGroupElem)</code></pre><p>If <code>x</code>,<code>y</code> are conjugate in <code>G</code>, return </p><pre><code class="language-none">true, z</code></pre><p>where <code>x^z=y</code>; otherwise, return</p><pre><code class="language-none">false, nothing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/GAPGroups.jl#L512-L523">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="representative_action-Tuple{Oscar.GAPGroup,Oscar.GAPGroup,Oscar.GAPGroup}" href="#representative_action-Tuple{Oscar.GAPGroup,Oscar.GAPGroup,Oscar.GAPGroup}"><code>representative_action</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">representative_action(G::Group, H::Group, K::Group)</code></pre><p>If <code>H</code>,<code>K</code> are conjugate subgroups in <code>G</code>, return </p><pre><code class="language-none">true, z</code></pre><p>where <code>H^z=K</code>; otherwise, return</p><pre><code class="language-none">false, nothing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/GAPGroups.jl#L581-L592">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="centralizer-Tuple{Oscar.GAPGroup,GAPGroupElem}" href="#centralizer-Tuple{Oscar.GAPGroup,GAPGroupElem}"><code>centralizer</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">centralizer(G::Group, x::GroupElem)</code></pre><p>Return the centralizer of <code>x</code> in <code>G</code>, i.e. the subgroup of all <code>g</code> in <code>G</code> such that <code>gx=xg</code>, together with its embedding morphism into <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/sub.jl#L216-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="centralizer-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Oscar.GAPGroup" href="#centralizer-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Oscar.GAPGroup"><code>centralizer</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">centralizer(G::Group, H::Group)</code></pre><p>Return the centralizer of <code>H</code> in <code>G</code>, i.e. the subgroup of all <code>g</code> in <code>G</code> such that <code>gh=hg</code> for every <code>h</code> in <code>H</code>, together with its embedding morphism into <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/sub.jl#L206-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="normalizer-Tuple{Oscar.GAPGroup,GAPGroupElem}" href="#normalizer-Tuple{Oscar.GAPGroup,GAPGroupElem}"><code>normalizer</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normalizer(G::Group, x::GAPGroupElem)</code></pre><p>Return <code>N,f</code>, where <code>N</code> is the normalizer of &lt;<code>x</code>&gt; in <code>G</code> and <code>f</code> is the embedding morphism of <code>N</code> into <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/GAPGroups.jl#L635-L639">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="normalizer-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Oscar.GAPGroup" href="#normalizer-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Oscar.GAPGroup"><code>normalizer</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normalizer(G::Group, H::Group)</code></pre><p>Return <code>N,f</code>, where <code>N</code> is the normalizer of <code>H</code> in <code>G</code> and <code>f</code> is the embedding morphism of <code>N</code> into <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/GAPGroups.jl#L628-L632">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="core-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Oscar.GAPGroup" href="#core-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Oscar.GAPGroup"><code>core</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">core(G::Group, H::Group)</code></pre><p>Return <code>C,f</code>, where <code>C</code> is the normal core of <code>H</code> in <code>G</code>, that is, the largest normal subgroup of <code>G</code> that is contained in <code>H</code>, and <code>f</code> is the embedding morphism of <code>C</code> into <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/GAPGroups.jl#L642-L648">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="normal_closure-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Oscar.GAPGroup" href="#normal_closure-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Oscar.GAPGroup"><code>normal_closure</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normal_closure(G::Group, H::Group)</code></pre><p>Return <code>N, f</code>, where <code>N</code> is the normal closure of <code>H</code> in <code>G</code>, that is, the smallest normal subgroup of <code>G</code> that contains <code>H</code>, and <code>f</code> is the embedding morphism of <code>N</code> into <code>G</code>.</p><p>Note that <code>H</code> must be a subgroup of <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/GAPGroups.jl#L651-L659">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GroupConjClass" href="#GroupConjClass"><code>GroupConjClass</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GroupConjClass</code></pre><p>It could be either the conjugacy class of an element or of a subgroup in a group G. It is displayed as</p><pre><code class="language-none">     cc = x ^ G</code></pre><p>where G is a group and x = <code>representative</code>(<code>cc</code>) is either an element or a subgroup of G.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/GAPGroups.jl#L440-L448">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="conjugacy_class-Tuple{Oscar.GAPGroup,GAPGroupElem}" href="#conjugacy_class-Tuple{Oscar.GAPGroup,GAPGroupElem}"><code>conjugacy_class</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">conjugacy_class(G::Group, g::GAPGroupElem) -&gt; GroupConjClass</code></pre><p>Return the conjugacy class <code>cc</code> of <code>g</code> in <code>G</code>, where <code>g</code> = <code>representative</code>(<code>cc</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/GAPGroups.jl#L478-L482">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="conjugacy_class-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Oscar.GAPGroup" href="#conjugacy_class-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Oscar.GAPGroup"><code>conjugacy_class</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">conjugacy_class(G::T, H::T) where T&lt;:Group -&gt; GroupConjClass</code></pre><p>Return the subgroup conjugacy class <code>cc</code> of <code>H</code> in <code>G</code>, where <code>H</code> = <code>representative</code>(<code>cc</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/GAPGroups.jl#L535-L539">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="conjugacy_classes-Tuple{Oscar.GAPGroup}" href="#conjugacy_classes-Tuple{Oscar.GAPGroup}"><code>conjugacy_classes</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">conjugacy_classes(G::Group)</code></pre><p>Return the array of all conjugacy classes of elements in G. It is guaranteed that the class of the identity is in the first position.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/GAPGroups.jl#L493-L497">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="conjugacy_classes_subgroups-Tuple{Oscar.GAPGroup}" href="#conjugacy_classes_subgroups-Tuple{Oscar.GAPGroup}"><code>conjugacy_classes_subgroups</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">conjugacy_classes_subgroups(G::Group)</code></pre><p>Return the array of all conjugacy classes of subgroups of G.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/GAPGroups.jl#L548-L552">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="conjugacy_classes_maximal_subgroups-Tuple{Oscar.GAPGroup}" href="#conjugacy_classes_maximal_subgroups-Tuple{Oscar.GAPGroup}"><code>conjugacy_classes_maximal_subgroups</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">conjugacy_classes_maximal_subgroups(G::Group)</code></pre><p>Return the array of all conjugacy classes of maximal subgroups of G.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/GAPGroups.jl#L558-L562">source</a></section></article><h3 id="Cosets-(left/right/double)"><a class="docs-heading-anchor" href="#Cosets-(left/right/double)">Cosets (left/right/double)</a><a id="Cosets-(left/right/double)-1"></a><a class="docs-heading-anchor-permalink" href="#Cosets-(left/right/double)" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GroupCoset" href="#GroupCoset"><code>GroupCoset</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GroupCoset{T&lt;: Group, S &lt;: GAPGroupElem}</code></pre><p>Type of group cosets. It is displayed as <code>H * x</code> (right cosets) or <code>x * H</code> (left cosets), where <code>H</code> is a subgroup of a group <code>G</code> and <code>x</code> is an element of <code>G</code>. Two cosets are equal if, and only if, they are both left (resp. right) and they contain the same elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/cosets.jl#L21-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="right_coset-Tuple{Oscar.GAPGroup,GAPGroupElem}" href="#right_coset-Tuple{Oscar.GAPGroup,GAPGroupElem}"><code>right_coset</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">right_coset(H::Group, g::GAPGroupElem)
*(H::Group, g::GAPGroupElem)</code></pre><p>Return the coset <code>Hg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/cosets.jl#L46-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="left_coset-Tuple{Oscar.GAPGroup,GAPGroupElem}" href="#left_coset-Tuple{Oscar.GAPGroup,GAPGroupElem}"><code>left_coset</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">left_coset(H::Group, g::GAPGroupElem)
*(g::GAPGroupElem, H::Group)</code></pre><p>Return the coset <code>gH</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Since GAP supports right cosets only, the underlying GAP object of <code>left_coset(H,g)</code> is the right coset <code>H^(g^-1) * g</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/cosets.jl#L60-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="isright-Tuple{GroupCoset}" href="#isright-Tuple{GroupCoset}"><code>isright</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isright(c::GroupCoset)</code></pre><p>Return whether the coset <code>c</code> is a right coset of its acting domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/cosets.jl#L94-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="isleft-Tuple{GroupCoset}" href="#isleft-Tuple{GroupCoset}"><code>isleft</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isleft(c::GroupCoset)</code></pre><p>Return whether the coset <code>c</code> is a left coset of its acting domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/cosets.jl#L87-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="isbicoset-Tuple{GroupCoset}" href="#isbicoset-Tuple{GroupCoset}"><code>isbicoset</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isbicoset(C::GroupCoset)</code></pre><p>Return whether <code>C</code> is simultaneously a right coset and a left coset for the same subgroup <code>H</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/cosets.jl#L145-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="acting_domain-Tuple{GroupCoset}" href="#acting_domain-Tuple{GroupCoset}"><code>acting_domain</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">acting_domain(C::GroupCoset)</code></pre><p>If <code>C</code> = <code>Hx</code> or <code>xH</code>, return <code>H</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/cosets.jl#L129-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="representative-Tuple{GroupCoset}" href="#representative-Tuple{GroupCoset}"><code>representative</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">representative(C::GroupCoset)</code></pre><p>If <code>C</code> = <code>Hx</code> or <code>xH</code>, return <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/cosets.jl#L136-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="right_cosets-Tuple{Oscar.GAPGroup,Oscar.GAPGroup}" href="#right_cosets-Tuple{Oscar.GAPGroup,Oscar.GAPGroup}"><code>right_cosets</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">right_cosets(G::Group, H::Group)</code></pre><p>Return the array of the right cosets of <code>H</code> in <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/cosets.jl#L152-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="left_cosets-Tuple{Oscar.GAPGroup,Oscar.GAPGroup}" href="#left_cosets-Tuple{Oscar.GAPGroup,Oscar.GAPGroup}"><code>left_cosets</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">left_cosets(G::Group, H::Group)</code></pre><p>Return the array of the left cosets of <code>H</code> in <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/cosets.jl#L166-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="right_transversal-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Oscar.GAPGroup" href="#right_transversal-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Oscar.GAPGroup"><code>right_transversal</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">right_transversal(G::T, H::T) where T&lt;: Group</code></pre><p>Return a vector containing a complete set of representatives for right cosets for <code>H</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/cosets.jl#L183-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="left_transversal-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Oscar.GAPGroup" href="#left_transversal-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Oscar.GAPGroup"><code>left_transversal</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">left_transversal(G::T, H::T) where T&lt;: Group</code></pre><p>Return a vector containing a complete set of representatives for left cosets for <code>H</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/cosets.jl#L197-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GroupDoubleCoset" href="#GroupDoubleCoset"><code>GroupDoubleCoset</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GroupDoubleCoset{T&lt;: Group, S &lt;: GAPGroupElem}</code></pre><p>Group double coset. It is displayed as <code>H * x * K</code>, where <code>H</code> and <code>K</code> are subgroups of a group <code>G</code> and <code>x</code> is an element of <code>G</code>. Two double cosets are equal if, and only if, they contain the same elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/cosets.jl#L219-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="double_coset-Union{Tuple{T}, Tuple{T,GAPGroupElem{T},T}} where T&lt;:Oscar.GAPGroup" href="#double_coset-Union{Tuple{T}, Tuple{T,GAPGroupElem{T},T}} where T&lt;:Oscar.GAPGroup"><code>double_coset</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">double_coset(H::Group, x::GAPGroupElem, K::Group)
*(H::Group, x::GAPGroupElem, K::Group)</code></pre><p>returns the double coset <code>HxK</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/cosets.jl#L249-L254">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="double_cosets-Union{Tuple{T}, Tuple{T,T,T}} where T&lt;:Oscar.GAPGroup" href="#double_cosets-Union{Tuple{T}, Tuple{T,T,T}} where T&lt;:Oscar.GAPGroup"><code>double_cosets</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">double_cosets(G::T, H::T, K::T; NC=false) where T&lt;: GAPGroup</code></pre><p>Return the array of all the double cosets <code>HxK</code> for <code>x</code> in <code>G</code>. If <code>NC</code> = <code>true</code>, do not check whether <code>H</code> and <code>K</code> are subgroups of <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/cosets.jl#L269-L273">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="left_acting_group-Tuple{GroupDoubleCoset}" href="#left_acting_group-Tuple{GroupDoubleCoset}"><code>left_acting_group</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">left_acting_group(C::GroupDoubleCoset)</code></pre><p>if <code>C</code> = <code>HxK</code>, returns <code>H</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/cosets.jl#L316-L320">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="right_acting_group-Tuple{GroupDoubleCoset}" href="#right_acting_group-Tuple{GroupDoubleCoset}"><code>right_acting_group</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">right_acting_group(C::GroupDoubleCoset)</code></pre><p>if <code>C</code> = <code>HxK</code>, returns <code>K</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/cosets.jl#L323-L327">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="representative-Tuple{GroupDoubleCoset}" href="#representative-Tuple{GroupDoubleCoset}"><code>representative</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">representative(C::GroupDoubleCoset)</code></pre><p>if <code>C</code> = <code>HxK</code>, returns <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/cosets.jl#L309-L313">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="order-Tuple{Union{GroupCoset, GroupDoubleCoset}}" href="#order-Tuple{Union{GroupCoset, GroupDoubleCoset}}"><code>order</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">order(C::Union{GroupCoset,GroupDoubleCoset})</code></pre><p>Return the cardinality of the (double) coset <code>C</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/cosets.jl#L294-L298">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="rand-Tuple{Union{GroupCoset, GroupDoubleCoset}}" href="#rand-Tuple{Union{GroupCoset, GroupDoubleCoset}}"><code>rand</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rand(C::Union{GroupCoset,GroupDoubleCoset})</code></pre><p>Return a random element of the (double) coset <code>C</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/cosets.jl#L302-L306">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="intersect-Union{Tuple{AbstractArray{Union{GroupCoset, GroupDoubleCoset, T},1}}, Tuple{T}} where T&lt;:Oscar.GAPGroup" href="#intersect-Union{Tuple{AbstractArray{Union{GroupCoset, GroupDoubleCoset, T},1}}, Tuple{T}} where T&lt;:Oscar.GAPGroup"><code>intersect</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">intersect(V::AbstractVector{Union{T, GroupCoset, GroupDoubleCoset}}) where T &lt;: GAPGroup</code></pre><p>Return an array containing all elements belonging to all groups and cosets in the vector <code>V</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/cosets.jl#L342-L346">source</a></section></article><h2 id="quotient"><a class="docs-heading-anchor" href="#quotient">Quotients</a><a id="quotient-1"></a><a class="docs-heading-anchor-permalink" href="#quotient" title="Permalink"></a></h2><p>Quotient groups in Oscar can be defined using the instruction <code>quo</code> in two ways.</p><ul><li>Quotients by normal subgroups.</li></ul><article class="docstring"><header><a class="docstring-binding" id="quo-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Oscar.GAPGroup" href="#quo-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Oscar.GAPGroup"><code>quo</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">quo(G::T, H::T)</code></pre><p>Return the quotient group <code>G/H</code> of type <code>PcGroup</code> (if the quotient group is solvable) or <code>PermGroup</code> (otherwise), together with the projection <code>G</code> -&gt; <code>G/H</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/sub.jl#L309-L313">source</a></section></article><ul><li>Quotients by elements.</li></ul><article class="docstring"><header><a class="docstring-binding" id="quo-Union{Tuple{T}, Tuple{S}, Tuple{T,Array{S,1}}} where T&lt;:Oscar.GAPGroup where S&lt;:GAPGroupElem" href="#quo-Union{Tuple{T}, Tuple{S}, Tuple{T,Array{S,1}}} where T&lt;:Oscar.GAPGroup where S&lt;:GAPGroupElem"><code>quo</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">quo(G::T, elements::Vector{S})</code></pre><p>Return the quotient group <code>G/H</code> of type <code>FPGroup</code> (if <code>T</code>=<code>FPGroup</code>), <code>PcGroup</code> (if the quotient group is solvable) or <code>PermGroup</code> (otherwise), where <code>H</code> is the normal closure of <code>elements</code> in <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/sub.jl#L295-L299">source</a></section></article><p>This is the typical way to build finitely presented groups.</p><p><strong>Example:</strong></p><pre><code class="language-julia-repl">julia&gt; F=free_group(2);

julia&gt; (f1,f2)=gens(F);

julia&gt; G,_=quo(F,[f1^2,f2^3,(f1*f2)^2]);

julia&gt; isfinite(G)
true

julia&gt; isisomorphic(G,symmetric_group(3))[1]
true</code></pre><p>Similarly to the subgroups, the output consists of a pair (<code>Q</code>,<code>p</code>), where <code>Q</code> is the quotient group and <code>p</code> is the projection homomorphism of <code>G</code> into <code>Q</code>.</p><h2 id="Products-of-groups"><a class="docs-heading-anchor" href="#Products-of-groups">Products of groups</a><a id="Products-of-groups-1"></a><a class="docs-heading-anchor-permalink" href="#Products-of-groups" title="Permalink"></a></h2><h3 id="Direct-products"><a class="docs-heading-anchor" href="#Direct-products">Direct products</a><a id="Direct-products-1"></a><a class="docs-heading-anchor-permalink" href="#Direct-products" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DirectProductGroup" href="#DirectProductGroup"><code>DirectProductGroup</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DirectProductGroup</code></pre><p>Either direct product of two or more groups of any type, or subgroup of a direct product of groups.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/types.jl#L217-L221">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="direct_product-Tuple{AbstractArray{var&quot;#s283&quot;,1} where var&quot;#s283&quot;&lt;:Oscar.GAPGroup}" href="#direct_product-Tuple{AbstractArray{var&quot;#s283&quot;,1} where var&quot;#s283&quot;&lt;:Oscar.GAPGroup}"><code>direct_product</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">direct_product(L::AbstractVector{&lt;:GAPGroup}; morphisms)
direct_product(L::GAPGroup...)</code></pre><p>Return the direct product of the groups in the collection <code>L</code>.</p><p>The parameter <code>morphisms</code> is <code>false</code> by default. If it is set <code>true</code>, then the output is a triple (<code>G</code>, <code>emb</code>, <code>proj</code>), where <code>emb</code> and <code>proj</code> are the vectors of the embeddings (resp. projections) of the direct product <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/directproducts.jl#L31-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="inner_direct_product-Union{Tuple{AbstractArray{T,1}}, Tuple{T}} where T&lt;:Union{FPGroup, PcGroup, PermGroup}" href="#inner_direct_product-Union{Tuple{AbstractArray{T,1}}, Tuple{T}} where T&lt;:Union{FPGroup, PcGroup, PermGroup}"><code>inner_direct_product</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inner_direct_product(L::AbstractVector{T}; morphisms)
inner_direct_product(L::T...)</code></pre><p>Return a direct product of groups of the same type <code>T</code> as a group of type <code>T</code>. It works for <code>T</code> of the following types:</p><ul><li><code>PermGroup</code>, <code>PcGroup</code>, <code>FPGroup</code>.</li></ul><p>The parameter <code>morphisms</code> is <code>false</code> by default. If it is set <code>true</code>, then the output is a triple (<code>G</code>, <code>emb</code>, <code>proj</code>), where <code>emb</code> and <code>proj</code> are the vectors of the embeddings (resp. projections) of the direct product <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/directproducts.jl#L55-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="number_of_factors-Tuple{DirectProductGroup}" href="#number_of_factors-Tuple{DirectProductGroup}"><code>number_of_factors</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">number_of_factors(G::DirectProductGroup)</code></pre><p>Return the number of factors of <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/directproducts.jl#L84-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="cartesian_power-Tuple{Oscar.GAPGroup,Integer}" href="#cartesian_power-Tuple{Oscar.GAPGroup,Integer}"><code>cartesian_power</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cartesian_power(G::T, n::Int)</code></pre><p>Return the direct product of <code>n</code> copies of <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/directproducts.jl#L91-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="inner_cartesian_power-Union{Tuple{T}, Tuple{T,Integer}} where T&lt;:Oscar.GAPGroup" href="#inner_cartesian_power-Union{Tuple{T}, Tuple{T,Integer}} where T&lt;:Oscar.GAPGroup"><code>inner_cartesian_power</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inner_cartesian_power(G::T, n::Int; morphisms)</code></pre><p>Return the direct product of <code>n</code> copies of <code>G</code> as group of type <code>T</code>.</p><p>The parameter <code>morphisms</code> is <code>false</code> by default. If it is set <code>true</code>, then the output is a triple (<code>G</code>, <code>emb</code>, <code>proj</code>), where <code>emb</code> and <code>proj</code> are the vectors of the embeddings (resp. projections) of the direct product <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/directproducts.jl#L101-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="factor_of_direct_product-Tuple{DirectProductGroup,Integer}" href="#factor_of_direct_product-Tuple{DirectProductGroup,Integer}"><code>factor_of_direct_product</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">factor_of_direct_product(G::DirectProductGroup, j::Int)</code></pre><p>Return the <code>j</code>-th factor of <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/directproducts.jl#L113-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="as_perm_group-Tuple{DirectProductGroup}" href="#as_perm_group-Tuple{DirectProductGroup}"><code>as_perm_group</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">as_perm_group(G::DirectProductGroup)</code></pre><p>If <code>G</code> is direct product of permutations groups, return <code>G</code> as permutation group.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/directproducts.jl#L124-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="as_polycyclic_group-Tuple{DirectProductGroup}" href="#as_polycyclic_group-Tuple{DirectProductGroup}"><code>as_polycyclic_group</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">as_polycyclic_group(G::DirectProductGroup)</code></pre><p>If <code>G</code> is direct product of polycyclic groups, return <code>G</code> as polycyclic group.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/directproducts.jl#L137-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="embedding-Tuple{DirectProductGroup,Integer}" href="#embedding-Tuple{DirectProductGroup,Integer}"><code>embedding</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">embedding(G::DirectProductGroup, j::Integer)</code></pre><p>Return the embedding of the <code>j</code>-th component of <code>G</code> into <code>G</code>, for <code>j</code> = 1,...,#factors of <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/directproducts.jl#L150-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="projection-Tuple{DirectProductGroup,Integer}" href="#projection-Tuple{DirectProductGroup,Integer}"><code>projection</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">projection(G::DirectProductGroup, j::Integer)</code></pre><p>Return the projection of <code>G</code> into the <code>j</code>-th component of <code>G</code>, for <code>j</code> = 1,...,#factors of <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/directproducts.jl#L164-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="write_as_full-Tuple{DirectProductGroup}" href="#write_as_full-Tuple{DirectProductGroup}"><code>write_as_full</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">write_as_full(G::DirectProductGroup)</code></pre><p>If <code>G</code> is a subgroup of the direct product <code>G_1 x ... x G_n</code> such that <code>G = H_1 x ... x H_n</code> for <code>H_i</code> subgroup of <code>G_i</code>, return <code>G</code> as full direct product of the <code>H_i</code>. If such <code>H_i</code> do not exist, an ERROR is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/directproducts.jl#L205-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="isfull_direct_product-Tuple{DirectProductGroup}" href="#isfull_direct_product-Tuple{DirectProductGroup}"><code>isfull_direct_product</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isfull_direct_product(G::DirectProductGroup)</code></pre><p>Return whether <code>G</code> is direct product of its factors (<code>false</code> if it is a proper subgroup).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/directproducts.jl#L222-L226">source</a></section></article><h3 id="Semidirect-products"><a class="docs-heading-anchor" href="#Semidirect-products">Semidirect products</a><a id="Semidirect-products-1"></a><a class="docs-heading-anchor-permalink" href="#Semidirect-products" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="SemidirectProductGroup" href="#SemidirectProductGroup"><code>SemidirectProductGroup</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SemidirectProductGroup{S,T}</code></pre><p>Semidirect product of two groups of type <code>S</code> and <code>T</code> respectively, or subgroup of a semidirect product of groups.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/types.jl#L230-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="semidirect_product-Union{Tuple{S}, Tuple{T}, Tuple{S,GAPGroupHomomorphism{T,AutomorphismGroup{S}},T}} where S&lt;:Oscar.GAPGroup where T&lt;:Oscar.GAPGroup" href="#semidirect_product-Union{Tuple{S}, Tuple{T}, Tuple{S,GAPGroupHomomorphism{T,AutomorphismGroup{S}},T}} where S&lt;:Oscar.GAPGroup where T&lt;:Oscar.GAPGroup"><code>semidirect_product</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">semidirect_product(N::S, f::GAPGroupHomomorphism, H::T)</code></pre><p>Return the semidirect product of <code>N</code> and <code>H</code>, of type <span>$SemidirectProductGroup{S,T}$</span>, where <code>f</code> is a homomorphism from <code>H</code> to <code>Aut</code>(<code>N</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/directproducts.jl#L238-L242">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="normal_subgroup-Tuple{SemidirectProductGroup}" href="#normal_subgroup-Tuple{SemidirectProductGroup}"><code>normal_subgroup</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normal_subgroup(G::SemidirectProductGroup)</code></pre><p>Return <code>N</code>, where <code>G</code> is the semidirect product of the normal subgroup <code>N</code> and <code>H</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/directproducts.jl#L256-L260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="acting_subgroup-Tuple{SemidirectProductGroup}" href="#acting_subgroup-Tuple{SemidirectProductGroup}"><code>acting_subgroup</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">acting_subgroup(G::SemidirectProductGroup)</code></pre><p>Return <code>H</code>, where <code>G</code> is the semidirect product of the normal subgroup <code>N</code> and <code>H</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/directproducts.jl#L263-L267">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="homomorphism_of_semidirect_product-Tuple{SemidirectProductGroup}" href="#homomorphism_of_semidirect_product-Tuple{SemidirectProductGroup}"><code>homomorphism_of_semidirect_product</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">homomorphism_of_semidirect_product(G::SemidirectProductGroup)</code></pre><p>Return <code>f,</code> where <code>G</code> is the semidirect product of the normal subgroup <code>N</code> and the group <code>H</code> acting on <code>N</code> via the homomorphism <code>h</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/directproducts.jl#L270-L274">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="isfull_semidirect_product-Tuple{SemidirectProductGroup}" href="#isfull_semidirect_product-Tuple{SemidirectProductGroup}"><code>isfull_semidirect_product</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isfull_semidirect_product(G::SemidirectProductGroup)</code></pre><p>Return whether <code>G</code> is a semidirect product of two groups, instead of a proper subgroup.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/directproducts.jl#L277-L281">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="embedding-Union{Tuple{S}, Tuple{T}, Tuple{SemidirectProductGroup{S,T},Integer}} where S where T" href="#embedding-Union{Tuple{S}, Tuple{T}, Tuple{SemidirectProductGroup{S,T},Integer}} where S where T"><code>embedding</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">embedding(G::SemidirectProductGroup, n::Integer)</code></pre><p>Return the embedding of the <code>n</code>-th component of <code>G</code> into <code>G</code>, for <code>n</code> = 1,2. It is not defined for proper subgroups of semidirect products.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/directproducts.jl#L284-L288">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="projection-Tuple{SemidirectProductGroup}" href="#projection-Tuple{SemidirectProductGroup}"><code>projection</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">projection(G::SemidirectProductGroup, n::Integer)</code></pre><p>Return the projection of <code>G</code> into the second component of <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/directproducts.jl#L305-L309">source</a></section></article><h3 id="Wreath-products"><a class="docs-heading-anchor" href="#Wreath-products">Wreath products</a><a id="Wreath-products-1"></a><a class="docs-heading-anchor-permalink" href="#Wreath-products" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="WreathProductGroup" href="#WreathProductGroup"><code>WreathProductGroup</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">WreathProductGroup</code></pre><p>Wreath product of a group <code>G</code> and a group of permutations <code>H</code>, or a generic group <code>H</code> together with the homomorphism <code>a</code> from <code>H</code> to a permutation group.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/types.jl#L244-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="wreath_product-Union{Tuple{T}, Tuple{T,PermGroup}} where T&lt;:Oscar.GAPGroup" href="#wreath_product-Union{Tuple{T}, Tuple{T,PermGroup}} where T&lt;:Oscar.GAPGroup"><code>wreath_product</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">wreath_product(G::T, H::S, a::GAPGroupHomomorphism{S,PermGroup})
wreath_product(G::T, H::PermGroup) where T&lt;: Group</code></pre><p>Return the wreath product of the group <code>G</code> and the group <code>H</code>, where <code>H</code> acts on <code>n</code> copies of <code>G</code> through the homomorphism <code>a</code> from <code>H</code> to a permutation group, and <code>n</code> is the number of moved points of <code>Image(a)</code>.</p><p>If <code>a</code> is not specified, then <code>H</code> must be a group of permutations. In this case, <code>n</code> is NOT the number of moved points, but the degree of <code>H</code>.</p><p>If <code>W</code> is a wreath product of <code>G</code> and <code>H</code>, {<code>g_1</code>, ..., <code>g_n</code>} are elements of <code>G</code> and <code>h</code> in <code>H</code>, the element <code>(g_1, ..., h)</code> of <code>W</code> can be obtained by typing</p><pre><code class="language-none">    W(g_1,...,g_n, h).</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/directproducts.jl#L336-L348">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="normal_subgroup-Tuple{WreathProductGroup}" href="#normal_subgroup-Tuple{WreathProductGroup}"><code>normal_subgroup</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normal_subgroup(W::WreathProductGroup)</code></pre><p>Return <code>G</code>, where <code>W</code> is the wreath product of <code>G</code> and <code>H</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/directproducts.jl#L381-L385">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="acting_subgroup-Tuple{WreathProductGroup}" href="#acting_subgroup-Tuple{WreathProductGroup}"><code>acting_subgroup</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">acting_subgroup(W::WreathProductGroup)</code></pre><p>Return <code>H</code>, where <code>W</code> is the wreath product of <code>G</code> and <code>H</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/directproducts.jl#L388-L392">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="homomorphism_of_wreath_product-Tuple{WreathProductGroup}" href="#homomorphism_of_wreath_product-Tuple{WreathProductGroup}"><code>homomorphism_of_wreath_product</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">homomorphism_of_wreath_product(G::WreathProductGroup)</code></pre><p>If <code>W</code> is the wreath product of <code>G</code> and <code>H</code>, then return the homomorphism <code>f</code> from <code>H</code> to <code>Sym(n)</code>, where <code>n</code> is the number of copies of <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/directproducts.jl#L395-L399">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="isfull_wreath_product-Tuple{WreathProductGroup}" href="#isfull_wreath_product-Tuple{WreathProductGroup}"><code>isfull_wreath_product</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isfull_wreath_product(G::WreathProductGroup)</code></pre><p>Return whether <code>G</code> is a wreath product of two groups, instead of a proper subgroup.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/directproducts.jl#L402-L406">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="projection-Tuple{WreathProductGroup}" href="#projection-Tuple{WreathProductGroup}"><code>projection</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">projection(G::WreathProductGroup)</code></pre><p>Return the projection of <code>wreath_product(G,H)</code> into the permutation group <code>H</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/directproducts.jl#L409-L413">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="embedding-Tuple{WreathProductGroup,Integer}" href="#embedding-Tuple{WreathProductGroup,Integer}"><code>embedding</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">embedding(G::WreathProductGroup, n::Integer)</code></pre><p>Return the embedding of the <code>n</code>-th component of <code>G</code> into <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/directproducts.jl#L422-L426">source</a></section></article><h2 id="Permutation-groups"><a class="docs-heading-anchor" href="#Permutation-groups">Permutation groups</a><a id="Permutation-groups-1"></a><a class="docs-heading-anchor-permalink" href="#Permutation-groups" title="Permalink"></a></h2><p>Permutation groups can be defined as symmetric groups, alternating groups or their subgroups.</p><article class="docstring"><header><a class="docstring-binding" id="PermGroup" href="#PermGroup"><code>PermGroup</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PermGroup</code></pre><p>Groups of permutations. Every group of this type is the subgroup of Sym(n) for some n.</p><p><strong>Examples</strong></p><ul><li><code>symmetric_group(n::Int)</code>: the symmetric group Sym(n)</li><li><code>alternating_group(n::Int)</code>: the alternating group Alt(n)</li><li>subgroups of Sym(n)</li><li><code>dihedral_group(PermGroup, n::Int)</code>: the dihedral group D(n) as group of permutations. Same holds replacing <code>dihedral_group</code> by <code>quaternion_group</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/types.jl#L91-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PermGroupElem" href="#PermGroupElem"><code>PermGroupElem</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PermGroupElem</code></pre><p>Element of a group of permutation. It is displayed as product of disjoint cycles.</p><p><strong>Assumptions:</strong></p><ul><li>for <code>x</code>,<code>y</code> in Sym(n), the product <code>xy</code> is read from left to right;</li><li>for <code>x</code> in Sym(n) and <code>i</code> in {1,...,n}, <code>i^x</code> and <code>x(i)</code> return the image of <code>i</code> under the action of <code>x</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/types.jl#L121-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="symmetric_group" href="#symmetric_group"><code>symmetric_group</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">symmetric_group(n::Int64)
symmetric_group(::Type{T}, n::Int)</code></pre><p>Return the full symmetric group over a set of <code>n</code> elements. The group is returned of type <code>T</code> for <code>T</code> in {<code>PermGroup</code>, <code>PcGroup</code>}. If <code>T</code> is not specified, then <code>T</code> is set as <code>PermGroup</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/group_constructors.jl#L42-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="alternating_group" href="#alternating_group"><code>alternating_group</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">alternating_group(n::Int64)
alternating_group(::Type{T}, n::Int)</code></pre><p>Return the full alternating group over a set of <code>n</code> elements. The group is returned of type <code>T</code> for <code>T</code> in {<code>PermGroup</code>, <code>PcGroup</code>}. If <code>T</code> is not specified, then <code>T</code> is set as <code>PermGroup</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/group_constructors.jl#L63-L68">source</a></section></article><p>In Oscar, every permutation group has a degree <code>n</code>, that corresponds to the size of the set on which <code>G</code> acts.</p><article class="docstring"><header><a class="docstring-binding" id="degree-Tuple{PermGroup}" href="#degree-Tuple{PermGroup}"><code>degree</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">degree(G::PermGroup)</code></pre><p>Return the degree as permutation group, that is the integer <code>n</code> such that <code>G &lt; Sym(n)</code>.</p><div class="admonition is-warning"><header class="admonition-header">Note</header><div class="admonition-body"><p>This is <em>not</em> the smallest <code>k</code> such that <code>G</code> embeds in <code>Sym(k)</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/GAPGroups.jl#L95-L102">source</a></section></article><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The degree of a group of permutations is not necessarily equal to the largest moved point of the group <code>G</code>. For example, the trivial subgroup of <code>symmetric_group(n)</code> has degree <code>n</code> even though it fixes <code>n</code>.</p></div></div><h3 id="Permutations"><a class="docs-heading-anchor" href="#Permutations">Permutations</a><a id="Permutations-1"></a><a class="docs-heading-anchor-permalink" href="#Permutations" title="Permalink"></a></h3><p>Permutations in Oscar are displayed as products of disjoint cycles, as in GAP. An explicit permutation can be built using the functions <code>perm</code>, <code>gap_perm</code> and <code>cperm</code>.</p><article class="docstring"><header><a class="docstring-binding" id="perm" href="#perm"><code>perm</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">perm(G::PermGroup, L::AbstractVector{&lt;:Integer})
(G::PermGroup)(L::AbstractVector{&lt;:Integer})</code></pre><p>Return the permutation <code>x</code> which maps every <code>i</code> from <code>1</code> to <code>length(L)</code> to <code>L[i]</code>. <code>L</code> must contain every integer from 1 to <code>length(L)</code> exactly, otherwise an exception is thrown. The parent of <code>x</code> is <code>G</code>. If <code>x</code> is not contained in <code>G</code>, an ERROR is returned. For <code>gap_perm</code>, the parent group of <code>x</code> is set as Sym(<code>n</code>), where <code>n</code> is the largest moved point of <code>x</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; perm(symmetric_group(6),[2,4,6,1,3,5])
(1,2,4)(3,6,5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/GAPGroups.jl#L282-L294">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="gap_perm" href="#gap_perm"><code>gap_perm</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gap_perm(L::AbstractVector)</code></pre><p>Return the permutation <code>x</code> which maps every <code>i</code> from <code>1</code> to <code>length(L)</code> to <code>L[i]</code>. <code>L</code> must contain every integer from 1 to <code>length(L)</code> exactly, otherwise an exception is thrown. The parent of <code>x</code> is set as Sym(<code>n</code>).</p><pre><code class="language-julia-repl">julia&gt; gap_perm([2,4,6,1,3,5])
(1,2,4)(3,6,5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/GAPGroups.jl#L266-L275">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="cperm" href="#cperm"><code>cperm</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cperm(L::AbstractVector{&lt;:T}...) where T &lt;: Union{Base.Integer, fmpz}
cperm(G::PermGroup, L::AbstractVector{&lt;:T}...)</code></pre><p>For given lists of positive integers <code>[a_1, a_2, ..., a_n],[b_1, b_2, ... , b_m], ...</code> return the permutation <code>x = (a_1,a_2,...,a_n)(b_1,b_2,...,b_m)...</code>. The array <code>[n,n+1,...,n+k]</code> can be replaced by <code>n:n+k</code>.</p><p>If a list is empty or contains duplicates, it fails. The parent of <code>x</code> is <code>G</code>. If <code>x</code> is not contained in <code>G</code>, an ERROR is returned. If <code>G</code> is not specified, then the parent of <code>x</code> is set as Sym(<code>n</code>), where <code>n</code> is the largest moved point of <code>x</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; cperm([1,2,3],4:7)
(1,2,3)(4,5,6,7)

julia&gt; cperm([1,2],[2,3])
(1,3,2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/GAPGroups.jl#L317-L335">source</a></section></article><p><strong>Example:</strong></p><pre><code class="language-julia-repl">julia&gt; perm(symmetric_group(6),[2,4,6,1,3,5])
(1,2,4)(3,6,5)

julia&gt; cperm([1,2,3],4:7)
(1,2,3)(4,5,6,7)

julia&gt; cperm([1,2],[2,3])
(1,3,2)</code></pre><p>At the moment, the input vectors of the function <code>cperm</code> need not to be disjoint.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>If the function <code>perm</code> is evaluated in a vector of integers without specifying the group <code>G</code>, then the returned value is an element of the AbstractAlgebra.jl type <code>Perm{Int}</code>. For this reason, if one wants a permutation of type <code>GAPGroupElem{PermGroup}</code> without specifying a parent, one has to use the function <code>gap_perm</code>.</p></div></div><p>Every permutation has always a permutation group as a parent. Two permutations coincide if, and only if, they move the same points and their parent groups have the same degree.</p><pre><code class="language-julia-repl">julia&gt; G=symmetric_group(5);

julia&gt; A=alternating_group(5);

julia&gt; x=cperm(G,[1,2,3]);

julia&gt; y=cperm(A,[1,2,3]);

julia&gt; z=cperm([1,2,3]);

julia&gt; x==y
true

julia&gt; x==z
false</code></pre><p>In the example above, <code>x</code> and <code>y</code> are equal because both act on a set of cardinality <code>5</code>, while <code>x</code> and <code>z</code> are different because <code>x</code> belongs to <code>Sym(5)</code> and <code>z</code> belongs to <code>Sym(2)</code>.</p><p>If <code>G</code> is a group and <code>x</code> is a permutation, it is possible to set <code>G</code> as parent of <code>x</code> simply typing <code>G(x)</code>. This returns the permutation <code>x</code> as element of <code>G</code> (or ERROR if <code>x</code> does not embed into <code>G</code>).</p><pre><code class="language-julia-repl">julia&gt; G=symmetric_group(5);

julia&gt; x=cperm([1,2,3]);

julia&gt; y=G(x);

julia&gt; parent(x)
Sym( [ 1 .. 3 ] )

julia&gt; parent(y)
Sym( [ 1 .. 5 ] )</code></pre><p>The function <code>Vector{T}</code> works in the opposite way with respect to <code>perm</code>:</p><article class="docstring"><header><a class="docstring-binding" id="Vector" href="#Vector"><code>Vector</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Vector{T}(x::PermGroupElem, n::Int = x.parent.deg) where {T}
Vector(x::PermGroupElem, n::Int = x.parent.deg)</code></pre><p>Return the list of length <code>n</code> that contains <code>x(i)</code> at position <code>i</code>. If not specified, <code>T</code> is set as <code>Int</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/GAPGroups.jl#L362-L367">source</a></section></article><h4 id="Permutations-as-functions"><a class="docs-heading-anchor" href="#Permutations-as-functions">Permutations as functions</a><a id="Permutations-as-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Permutations-as-functions" title="Permalink"></a></h4><p>A permutation can be viewed as a function on the set <code>{1,...,n}</code>, hence it can be evaluated on integers.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The multiplication between permutations works from the left to the right. So, if <code>x</code> and <code>y</code> are permutations and <code>n</code> is an integer, then <code>(x*y)(n) = (y(x(n))</code>, NOT <code>x(y(n))</code>.</p></div></div><pre><code class="language-julia-repl">julia&gt; x = cperm([1,2,3,4,5]);

julia&gt; x(2)
3</code></pre><p>This works also if the argument is not in the range <code>1:n</code>; in such a case, the output coincides with the input.</p><h2 id="Finitely-presented-groups"><a class="docs-heading-anchor" href="#Finitely-presented-groups">Finitely presented groups</a><a id="Finitely-presented-groups-1"></a><a class="docs-heading-anchor-permalink" href="#Finitely-presented-groups" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FPGroup" href="#FPGroup"><code>FPGroup</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FPGroup</code></pre><p>Finitely presented group. It can be defined via the function <code>free_group</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/types.jl#L158-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FPGroupElem" href="#FPGroupElem"><code>FPGroupElem</code></a> â <span class="docstring-category">Type</span></header><section><div><p>TODO: document this</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/types.jl#L174-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="free_group-Tuple{Int64}" href="#free_group-Tuple{Int64}"><code>free_group</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">free_group</code></pre><p>There are four ways to define a free group.</p><ul><li><code>free_group(n::Int) -&gt; FPGroup</code>; return the free group of rank <code>n</code>, with generators printed as <code>&quot;f1&quot;</code>,<code>&quot;f2&quot;</code>,<code>&quot;f3&quot;</code>, etc.</li><li><code>free_group(L::String...) -&gt; FPGroup</code>; return the free group with length(<code>L</code>) generators, printed as <code>L[1]</code>, <code>L[2]</code>, <code>L[3]</code>, etc.</li><li><code>free_group(L::Array{String,1}) -&gt; FPGroup</code>; same as above.</li><li><code>free_group(n::Int, s::String) -&gt; FPGroup</code>; return the free group of rank <code>n</code>, with generators printed as <code>&quot;s1&quot;</code>, <code>&quot;s2&quot;</code>, <code>&quot;s3&quot;</code>, etc.</li></ul><div class="admonition is-warning"><header class="admonition-header">Note</header><div class="admonition-body"><p>In every case, it is <em>not</em> defined a variable named as the generators are printed.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/group_constructors.jl#L141-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="relators-Tuple{FPGroup}" href="#relators-Tuple{FPGroup}"><code>relators</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">relators(G::FPGroup)</code></pre><p>Return a list of relators for the finitely presented group, i.e. elements <code>[x_1, ... , x_n]</code> in <code>F</code> = <code>free_group(ngens(G))</code> such that <code>G = F/[x_1,...,x_n]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/GAPGroups.jl#L829-L833">source</a></section></article><h2 id="Polycyclic-groups"><a class="docs-heading-anchor" href="#Polycyclic-groups">Polycyclic groups</a><a id="Polycyclic-groups-1"></a><a class="docs-heading-anchor-permalink" href="#Polycyclic-groups" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PcGroup" href="#PcGroup"><code>PcGroup</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PcGroup</code></pre><p>Polycyclic group</p><p><strong>Examples</strong></p><ul><li><code>cyclic_group(n::Int)</code>: cyclic group of order <code>n</code></li><li><code>abelian_group(v::Vector{Int})</code>: direct product of cyclic groups of order v[1],v[2],...,v[length(v)]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/types.jl#L131-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PcGroupElem" href="#PcGroupElem"><code>PcGroupElem</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PcGroupElem</code></pre><p>Element of a polycyclic group.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/types.jl#L151-L155">source</a></section></article><p>Julia has the following functions that allow to generate polycyclic groups:</p><article class="docstring"><header><a class="docstring-binding" id="abelian_group-Union{Tuple{T}, Tuple{Type{T},Array{Int64,1}}} where T&lt;:Oscar.GAPGroup" href="#abelian_group-Union{Tuple{T}, Tuple{Type{T},Array{Int64,1}}} where T&lt;:Oscar.GAPGroup"><code>abelian_group</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">abelian_group(::Type{T}, v::Vector{Int}) where T &lt;: Group -&gt; PcGroup</code></pre><p>Return the direct product of cyclic groups of order v[1] x v[2] x ... x v[n], as group of type <code>T</code>. Here, <code>T</code> must be of type <code>PermGroup</code>, <code>FPGroup</code> or <code>PcGroup</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/group_constructors.jl#L110-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="cyclic_group" href="#cyclic_group"><code>cyclic_group</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cyclic_group(::Type{T}, n::Int)</code></pre><p>Return the cyclic group of order <code>n</code> and type <code>T</code>. If the type is not specified, the group is returned of type <code>PcGroup</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/group_constructors.jl#L86-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="dihedral_group" href="#dihedral_group"><code>dihedral_group</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dihedral_group(n::Int)
dihedral_group(::Type{T}, n::Int)</code></pre><p>Return the dihedral group of order <code>n</code> of type <code>T</code>, where <code>T</code> is in {<code>PcGroup</code>,<code>PermGroup</code>,<code>FPGroup</code>}. In the first case, the type is set as <code>PcGroup</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/group_constructors.jl#L195-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="quaternion_group" href="#quaternion_group"><code>quaternion_group</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">quaternion_group(n::Int)
quaternion_group(::Type{T}, n::Int)</code></pre><p>Return the quaternion group of order <code>n</code> of type <code>T</code>, where <code>T</code> is in {<code>PcGroup</code>,<code>PermGroup</code>,<code>FPGroup</code>}. In the first case, the type is set as <code>PcGroup</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/group_constructors.jl#L208-L213">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The type need to be specified in the input of the function <code>abelian_group</code>, otherwise a group of type <code>GrpAbFinGen</code> is returned, which is not a GAP group type. In future versions of Oscar, this may change.</p></div></div><p>The generators of a polycyclic group are displayed as <code>f1</code>, <code>f2</code>, <code>f3</code>, etc., and every element of a polycyclic group is displayed as product of such generators.</p><p><strong>Example:</strong></p><pre><code class="language-julia-repl">julia&gt; G=abelian_group(PcGroup, [2,4]);

julia&gt; G[1], G[2]
(f1, f2)

julia&gt; G[2]*G[1]
f1*f2</code></pre><p>Note that this does not define Julia variables named <code>f1</code>, <code>f2</code>, etc.! To get the generators of the group <code>G</code>, use <code>gens(G)</code>; for convenience they can also be accessed as <code>G[1]</code>, <code>G[2]</code>, as shown in Section <a href="#elements_of_groups">Elements of groups</a>.</p><h2 id="Matrix-groups"><a class="docs-heading-anchor" href="#Matrix-groups">Matrix groups</a><a id="Matrix-groups-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-groups" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MatrixGroup" href="#MatrixGroup"><code>MatrixGroup</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MatrixGroup{RE&lt;:RingElem, T&lt;:MatElem{RE}} &lt;: GAPGroup</code></pre><p>Type of groups <code>G</code> of <code>n x n</code> matrices over the ring <code>R</code>, where <code>n = degree(G)</code> and <code>R = base_ring(G)</code>.</p><p>At the moment, only rings of type <code>FqNmodFiniteField</code> are supported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/MatGrp.jl#L27-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MatrixGroupElem" href="#MatrixGroupElem"><code>MatrixGroupElem</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MatrixGroupElem{RE&lt;:RingElem, T&lt;:MatElem{RE}} &lt;: AbstractMatrixGroupElem</code></pre><p>Elements of a group of type <code>MatrixGroup{RE&lt;:RingElem, T&lt;:MatElem{RE}}</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/MatGrp.jl#L85-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="base_ring-Tuple{MatrixGroup}" href="#base_ring-Tuple{MatrixGroup}"><code>base_ring</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">base_ring(G::MatrixGroup)</code></pre><p>Return the base ring of the matrix group <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/MatGrp.jl#L474-L478">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="degree-Tuple{MatrixGroup}" href="#degree-Tuple{MatrixGroup}"><code>degree</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">degree(G::MatrixGroup)</code></pre><p>Return the degree of the matrix group <code>G</code>, i.e. the number of rows of its matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/MatGrp.jl#L481-L485">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="centralizer-Union{Tuple{T}, Tuple{MatrixGroup{T,T1} where T1&lt;:MatElem{T},MatrixGroupElem{T,T1} where T1&lt;:MatElem{T}}} where T&lt;:FinFieldElem" href="#centralizer-Union{Tuple{T}, Tuple{MatrixGroup{T,T1} where T1&lt;:MatElem{T},MatrixGroupElem{T,T1} where T1&lt;:MatElem{T}}} where T&lt;:FinFieldElem"><code>centralizer</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">centralizer(G::MatrixGroup{T}, x::MatrixGroupElem{T})</code></pre><p>Return (<code>C</code>,<code>f</code>), where <code>C</code> is the centralizer of <code>x</code> in <code>C</code> and <code>f</code> is the embedding of <code>C</code> into <code>G</code>. If <code>G</code> = <code>GL(n,F)</code> or <code>SL(n,F)</code>, then <code>f</code> = <code>nothing</code>. In this case, to get the embedding homomorphism of <code>C</code> into <code>G</code>, use</p><blockquote><p><code>issubgroup(G,C)[2]</code></p></blockquote></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/linear_centralizer.jl#L433-L439">source</a></section></article><h3 id="Elements-of-matrix-groups"><a class="docs-heading-anchor" href="#Elements-of-matrix-groups">Elements of matrix groups</a><a id="Elements-of-matrix-groups-1"></a><a class="docs-heading-anchor-permalink" href="#Elements-of-matrix-groups" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="matrix-Tuple{MatrixGroupElem}" href="#matrix-Tuple{MatrixGroupElem}"><code>matrix</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">matrix(x::MatrixGroupElem)</code></pre><p>Return the underlying <code>AbstractAlgebra</code> matrix of <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/MatGrp.jl#L432-L436">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="base_ring-Tuple{MatrixGroupElem}" href="#base_ring-Tuple{MatrixGroupElem}"><code>base_ring</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">base_ring(x::MatrixGroupElem)</code></pre><p>Return the base ring of <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/MatGrp.jl#L423-L427">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="nrows-Tuple{MatrixGroupElem}" href="#nrows-Tuple{MatrixGroupElem}"><code>nrows</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nrows(x::MatrixGroupElem)</code></pre><p>Return the number of rows of the given matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/MatGrp.jl#L441-L445">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="det-Tuple{MatrixGroupElem}" href="#det-Tuple{MatrixGroupElem}"><code>det</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">det(x::MatrixGroupElem)</code></pre><p>Return the determinant of <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/MatGrp.jl#L416-L420">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="trace-Tuple{MatrixGroupElem}" href="#trace-Tuple{MatrixGroupElem}"><code>trace</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">trace(x::MatrixGroupElem)
tr(x::MatrixGroupElem)</code></pre><p>Return the trace of <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/MatGrp.jl#L448-L453">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="multiplicative_jordan_decomposition-Tuple{MatrixGroupElem}" href="#multiplicative_jordan_decomposition-Tuple{MatrixGroupElem}"><code>multiplicative_jordan_decomposition</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">multiplicative_jordan_decomposition(M::MatrixGroupElem)</code></pre><p>Return <code>S</code> and <code>U</code> in the group <code>G = parent(M)</code> such that <code>S</code> is semisimple, <code>U</code> is unipotent and  <code>M = SU = US</code>.</p><div class="admonition is-warning"><header class="admonition-header">WARNING:</header><div class="admonition-body"><p>this is <em>NOT</em>, in general, the same output returned when <code>M</code> has type <code>MatElem</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/linear_isconjugate.jl#L24-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="issemisimple-Union{Tuple{MatrixGroupElem{T,T1} where T1&lt;:MatElem{T}}, Tuple{T}} where T&lt;:FinFieldElem" href="#issemisimple-Union{Tuple{MatrixGroupElem{T,T1} where T1&lt;:MatElem{T}}, Tuple{T}} where T&lt;:FinFieldElem"><code>issemisimple</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">issemisimple(x::MatrixGroupElem{T}) where T &lt;: FinFieldElem</code></pre><p>Return whether <code>x</code> is semisimple, i.e. has order coprime with the characteristic of its base ring.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/linear_isconjugate.jl#L41-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="isunipotent-Union{Tuple{MatrixGroupElem{T,T1} where T1&lt;:MatElem{T}}, Tuple{T}} where T&lt;:FinFieldElem" href="#isunipotent-Union{Tuple{MatrixGroupElem{T,T1} where T1&lt;:MatElem{T}}, Tuple{T}} where T&lt;:FinFieldElem"><code>isunipotent</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isunipotent(x::MatrixGroupElem{T}) where T &lt;: FinFieldElem</code></pre><p>Return whether <code>x</code> is unipotent, i.e. its order is a power of the characteristic of its base ring.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/linear_isconjugate.jl#L48-L52">source</a></section></article><h3 id="Sesquilinear-forms"><a class="docs-heading-anchor" href="#Sesquilinear-forms">Sesquilinear forms</a><a id="Sesquilinear-forms-1"></a><a class="docs-heading-anchor-permalink" href="#Sesquilinear-forms" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="SesquilinearForm" href="#SesquilinearForm"><code>SesquilinearForm</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SesquilinearForm{T&lt;:RingElem}</code></pre><p>Type of groups <code>G</code> of <code>n x n</code> matrices over the ring <code>R</code>, where <code>n = degree(G)</code> and <code>R = base_ring(G)</code>. At the moment, only rings of type <code>FqNmodFiniteField</code> are supported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/forms.jl#L30-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="isalternating_form-Tuple{SesquilinearForm}" href="#isalternating_form-Tuple{SesquilinearForm}"><code>isalternating_form</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isalternating_form(f::SesquilinearForm)</code></pre><p>Return whether the form <code>f</code> is an alternating form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/forms.jl#L83-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ishermitian_form-Tuple{SesquilinearForm}" href="#ishermitian_form-Tuple{SesquilinearForm}"><code>ishermitian_form</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ishermitian_form(f::SesquilinearForm)</code></pre><p>Return whether the form <code>f</code> is a hermitian form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/forms.jl#L90-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="isquadratic_form-Tuple{SesquilinearForm}" href="#isquadratic_form-Tuple{SesquilinearForm}"><code>isquadratic_form</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isquadratic_form(f::SesquilinearForm)</code></pre><p>Return whether the form <code>f</code> is a quadratic form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/forms.jl#L97-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="issymmetric_form-Tuple{SesquilinearForm}" href="#issymmetric_form-Tuple{SesquilinearForm}"><code>issymmetric_form</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">issymmetric_form(f::SesquilinearForm)</code></pre><p>Return whether the form <code>f</code> is a symmetric form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/forms.jl#L104-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="alternating_form-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:FieldElem" href="#alternating_form-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:FieldElem"><code>alternating_form</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">alternating_form(B::MatElem{T})</code></pre><p>Return the alternating form with Gram matrix <code>B</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/forms.jl#L119-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="symmetric_form-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:FieldElem" href="#symmetric_form-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:FieldElem"><code>symmetric_form</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">symmetric_form(B::MatElem{T})</code></pre><p>Return the symmetric form with Gram matrix <code>B</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/forms.jl#L126-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="hermitian_form-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:FieldElem" href="#hermitian_form-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:FieldElem"><code>hermitian_form</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hermitian_form(B::MatElem{T})</code></pre><p>Return the hermitian form with Gram matrix <code>B</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/forms.jl#L133-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="quadratic_form-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:FieldElem" href="#quadratic_form-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:FieldElem"><code>quadratic_form</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">quadratic_form(B::MatElem{T})</code></pre><p>Return the quadratic form with Gram matrix <code>B</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/forms.jl#L151-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="quadratic_form-Union{Tuple{MPolyElem{T}}, Tuple{T}} where T&lt;:FieldElem" href="#quadratic_form-Union{Tuple{MPolyElem{T}}, Tuple{T}} where T&lt;:FieldElem"><code>quadratic_form</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">quadratic_form(f::MPolyElem{T}; check=true)</code></pre><p>Return the quadratic form described by the polynomial <code>f</code>. Here, <code>f</code> must be a homogeneous polynomial of degree 2. If <code>check</code> is set as <code>false</code>, it does not check whether the polynomial is homogeneous of degree 2. To define quadratic forms of dimension 1, <code>f</code> can also have type <code>PolyElem{T}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/forms.jl#L158-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="corresponding_bilinear_form-Tuple{SesquilinearForm}" href="#corresponding_bilinear_form-Tuple{SesquilinearForm}"><code>corresponding_bilinear_form</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">corresponding_bilinear_form(Q::SesquilinearForm)</code></pre><p>Given a quadratic form <code>Q</code>, return the bilinear form <code>B</code> defined by <code>B(u,v) = Q(u+v)-Q(u)-Q(v)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/forms.jl#L218-L222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="corresponding_quadratic_form-Tuple{SesquilinearForm}" href="#corresponding_quadratic_form-Tuple{SesquilinearForm}"><code>corresponding_quadratic_form</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">corresponding_quadratic_form(Q::SesquilinearForm)</code></pre><p>Given a symmetric form <code>f</code>, returns the quadratic form <code>Q</code> defined by <code>Q(v) = f(v,v)/2</code>. It is defined only in odd characteristic.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/forms.jl#L231-L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="gram_matrix-Tuple{SesquilinearForm}" href="#gram_matrix-Tuple{SesquilinearForm}"><code>gram_matrix</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gram_matrix(B::SesquilinearForm)</code></pre><p>Return the Gram matrix of a sesquilinear or quadratic form <code>B</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/forms.jl#L259-L263">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="defining_polynomial-Tuple{SesquilinearForm}" href="#defining_polynomial-Tuple{SesquilinearForm}"><code>defining_polynomial</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">defining_polynomial(f::SesquilinearForm)</code></pre><p>Return the polynomial that defines the quadratic form <code>f</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/forms.jl#L292-L296">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="radical-Union{Tuple{SesquilinearForm{T}}, Tuple{T}} where T" href="#radical-Union{Tuple{SesquilinearForm{T}}, Tuple{T}} where T"><code>radical</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia"> radical(A::AbsAlgAss) -&gt; AbsAlgAssIdl</code></pre><p>Returns the Jacobson-Radical of <span>$A$</span>.</p></div></section><section><div><pre><code class="language-none">radical(f::SesquilinearForm{T})</code></pre><p>Return the radical of the sesquilinear form <code>f</code>, i.e. the subspace of all <code>v</code> such that <code>f(u,v)=0</code> for all <code>u</code>. The radical of a quadratic form <code>Q</code> is the set of vectors <code>v</code> such that <code>Q(v)=0</code>  and <code>v</code> lies in the radical of the corresponding bilinear form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/forms.jl#L402-L408">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="witt_index-Union{Tuple{SesquilinearForm{T}}, Tuple{T}} where T" href="#witt_index-Union{Tuple{SesquilinearForm{T}}, Tuple{T}} where T"><code>witt_index</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">witt_index(f::SesquilinearForm{T})</code></pre><p>Return the Witt index of the form induced by <code>f</code> on <code>V/Rad(f)</code>. The Witt Index is the dimension of a maximal totally isotropic (singular for quadratic forms) subspace.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/forms.jl#L421-L426">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="isdegenerate-Union{Tuple{SesquilinearForm{T}}, Tuple{T}} where T" href="#isdegenerate-Union{Tuple{SesquilinearForm{T}}, Tuple{T}} where T"><code>isdegenerate</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isdegenerate(f::SesquilinearForm{T})</code></pre><p>Return whether <code>f</code> is degenerate, i.e. <code>f</code> has nonzero radical. A quadratic form is degenerate if the corresponding bilinear form is.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/forms.jl#L429-L433">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="issingular-Union{Tuple{SesquilinearForm{T}}, Tuple{T}} where T" href="#issingular-Union{Tuple{SesquilinearForm{T}}, Tuple{T}} where T"><code>issingular</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">issingular(Q::SesquilinearForm{T})</code></pre><p>For a quadratic form <code>Q</code>, return whether <code>Q</code> is singular, i.e. <code>Q</code> has nonzero radical.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/forms.jl#L439-L443">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="iscongruent-Union{Tuple{T}, Tuple{SesquilinearForm{T},SesquilinearForm{T}}} where T&lt;:RingElem" href="#iscongruent-Union{Tuple{T}, Tuple{SesquilinearForm{T},SesquilinearForm{T}}} where T&lt;:RingElem"><code>iscongruent</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">iscongruent(f::SesquilinearForm{T}, g::SesquilinearForm{T}) where T &lt;: RingElem</code></pre><p>If <code>f</code> and <code>g</code> are sesquilinear forms, return (<code>true</code>, <code>C</code>) if there exists a matrix <code>C</code> such that <code>f^C = g</code>, or equivalently, <code>CBC* = A</code>, where <code>A</code> and <code>B</code> are the Gram matrices of <code>f</code> and <code>g</code> respectively, and <code>C*</code> is the transpose-conjugate matrix of <code>C</code>. If such <code>C</code> does not exist, then return (<code>false</code>, <code>nothing</code>). If <code>f</code> and <code>g</code> are quadratic forms, return (<code>true</code>, <code>C</code>) if there exists a matrix <code>C</code> such that <code>f^A = ag</code> for some scalar <code>a</code>. If such <code>C</code> does not exist, then return (<code>false</code>, <code>nothing</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/transform_form.jl#L372-L377">source</a></section></article><h3 id="Invariant-forms"><a class="docs-heading-anchor" href="#Invariant-forms">Invariant forms</a><a id="Invariant-forms-1"></a><a class="docs-heading-anchor-permalink" href="#Invariant-forms" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="invariant_bilinear_forms-Union{Tuple{MatrixGroup{S,T}}, Tuple{T}, Tuple{S}} where T where S" href="#invariant_bilinear_forms-Union{Tuple{MatrixGroup{S,T}}, Tuple{T}, Tuple{S}} where T where S"><code>invariant_bilinear_forms</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">invariant_bilinear_forms(G::MatrixGroup)</code></pre><p>Return a generating set for the vector spaces of bilinear forms preserved by the group <code>G</code>.</p><div class="admonition is-warning"><header class="admonition-header">Note:</header><div class="admonition-body"><p>At the moment, elements of the generating set are returned of type <code>mat_elem_type(G)</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/form_group.jl#L29-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="invariant_sesquilinear_forms-Union{Tuple{MatrixGroup{S,T}}, Tuple{T}, Tuple{S}} where T where S" href="#invariant_sesquilinear_forms-Union{Tuple{MatrixGroup{S,T}}, Tuple{T}, Tuple{S}} where T where S"><code>invariant_sesquilinear_forms</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">invariant_sesquilinear_forms(G::MatrixGroup)</code></pre><p>Return a generating set for the vector spaces of sesquilinear non-bilinear forms preserved by the group <code>G</code>. It works only if <code>base_ring(G)</code> is a finite field with even degree on its prime subfield.</p><div class="admonition is-warning"><header class="admonition-header">Note:</header><div class="admonition-body"><p>At the moment, elements of the generating set are returned of type <code>mat_elem_type(G)</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/form_group.jl#L55-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="invariant_quadratic_forms-Union{Tuple{MatrixGroup{S,T}}, Tuple{T}, Tuple{S}} where T where S" href="#invariant_quadratic_forms-Union{Tuple{MatrixGroup{S,T}}, Tuple{T}, Tuple{S}} where T where S"><code>invariant_quadratic_forms</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">invariant_quadratic_forms(G::MatrixGroup)</code></pre><p>Return a generating set for the vector spaces of quadratic forms preserved by the group <code>G</code>.</p><div class="admonition is-warning"><header class="admonition-header">Note:</header><div class="admonition-body"><p>At the moment, elements of the generating set are returned of type <code>mat_elem_type(G)</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/form_group.jl#L84-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="invariant_symmetric_forms-Union{Tuple{MatrixGroup{S,T}}, Tuple{T}, Tuple{S}} where T where S" href="#invariant_symmetric_forms-Union{Tuple{MatrixGroup{S,T}}, Tuple{T}, Tuple{S}} where T where S"><code>invariant_symmetric_forms</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">invariant_symmetric_forms(G::MatrixGroup)</code></pre><p>Return a generating set for the vector spaces of symmetric forms preserved by the group <code>G</code>.</p><div class="admonition is-warning"><header class="admonition-header">Note:</header><div class="admonition-body"><p>At the moment, elements of the generating set are returned of type <code>mat_elem_type(G)</code>.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Note:</header><div class="admonition-body"><p>Work properly only in odd characteristic. In even characteristic, only alternating forms are found.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/form_group.jl#L124-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="invariant_alternating_forms-Union{Tuple{MatrixGroup{S,T}}, Tuple{T}, Tuple{S}} where T where S" href="#invariant_alternating_forms-Union{Tuple{MatrixGroup{S,T}}, Tuple{T}, Tuple{S}} where T where S"><code>invariant_alternating_forms</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">invariant_alternating_forms(G::MatrixGroup)</code></pre><p>Return a generating set for the vector spaces of alternating forms preserved by the group <code>G</code>.</p><div class="admonition is-warning"><header class="admonition-header">Note:</header><div class="admonition-body"><p>At the moment, elements of the generating set are returned of type <code>mat_elem_type(G)</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/form_group.jl#L137-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="invariant_hermitian_forms-Union{Tuple{MatrixGroup{S,T}}, Tuple{T}, Tuple{S}} where T where S" href="#invariant_hermitian_forms-Union{Tuple{MatrixGroup{S,T}}, Tuple{T}, Tuple{S}} where T where S"><code>invariant_hermitian_forms</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">invariant_hermitian_forms(G::MatrixGroup)</code></pre><p>Return a generating set for the vector spaces of hermitian forms preserved by the group <code>G</code>. It works only if <code>base_ring(G)</code> is a finite field with even degree on its prime subfield.</p><div class="admonition is-warning"><header class="admonition-header">Note:</header><div class="admonition-body"><p>At the moment, elements of the generating set are returned of type <code>mat_elem_type(G)</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/form_group.jl#L187-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="invariant_bilinear_form-Tuple{MatrixGroup}" href="#invariant_bilinear_form-Tuple{MatrixGroup}"><code>invariant_bilinear_form</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function invariant_bilinear_form(G::MatrixGroup)</code></pre><p>Return an invariant bilinear form for the group <code>G</code>. It works only if the module induced by the action of <code>G</code> is absolutely irreducible.</p><div class="admonition is-warning"><header class="admonition-header">Note:</header><div class="admonition-body"><p>At the moment, the output is returned of type <code>mat_elem_type(G)</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/form_group.jl#L414-L421">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="invariant_sesquilinear_form-Tuple{MatrixGroup}" href="#invariant_sesquilinear_form-Tuple{MatrixGroup}"><code>invariant_sesquilinear_form</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function invariant_sesquilinear_form(G::MatrixGroup)</code></pre><p>Return an invariant sesquilinear (non bilinear) form for the group <code>G</code>. It works only if the module induced by the action of <code>G</code> is absolutely irreducible.</p><div class="admonition is-warning"><header class="admonition-header">Note:</header><div class="admonition-body"><p>At the moment, the output is returned of type <code>mat_elem_type(G)</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/form_group.jl#L428-L435">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="invariant_quadratic_form-Tuple{MatrixGroup}" href="#invariant_quadratic_form-Tuple{MatrixGroup}"><code>invariant_quadratic_form</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function invariant_quadratic_form(G::MatrixGroup)</code></pre><p>Return an invariant bilinear form for the group <code>G</code>. It works only if the module induced by the action of <code>G</code> is absolutely irreducible.</p><div class="admonition is-warning"><header class="admonition-header">Note:</header><div class="admonition-body"><p>At the moment, the output is returned of type <code>mat_elem_type(G)</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/form_group.jl#L442-L449">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="preserved_quadratic_forms-Union{Tuple{MatrixGroup{S,T}}, Tuple{T}, Tuple{S}} where T where S" href="#preserved_quadratic_forms-Union{Tuple{MatrixGroup{S,T}}, Tuple{T}, Tuple{S}} where T where S"><code>preserved_quadratic_forms</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">preserved_quadratic_forms(G::MatrixGroup)</code></pre><p>Uses random methods to find all of the quadratic forms preserved by <code>G</code> up to a scalar (i.e. such that <code>G</code> is a group of similarities for the forms).  Since the procedure relies on a pseudo-random generator,  the user may need to execute the operation more than once to find all invariant quadratic forms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/form_group.jl#L467-L474">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="preserved_sesquilinear_forms-Union{Tuple{MatrixGroup{S,T}}, Tuple{T}, Tuple{S}} where T where S" href="#preserved_sesquilinear_forms-Union{Tuple{MatrixGroup{S,T}}, Tuple{T}, Tuple{S}} where T where S"><code>preserved_sesquilinear_forms</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">preserved_sesquilinear_forms(G::MatrixGroup)</code></pre><p>Uses random methods to find all of the sesquilinear forms preserved by <code>G</code> up to a scalar (i.e. such that <code>G</code> is a group of similarities for the forms). Since the procedure relies on a pseudo-random generator, the user may need to execute the operation more than once to find all invariant sesquilinear forms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/form_group.jl#L487-L494">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="isometry_group-Union{Tuple{SesquilinearForm{T}}, Tuple{T}} where T" href="#isometry_group-Union{Tuple{SesquilinearForm{T}}, Tuple{T}} where T"><code>isometry_group</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isometry_group(f::SesquilinearForm{T})</code></pre><p>Return the group of isometries for the sesquilinear form <code>f</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/form_group.jl#L545-L549">source</a></section></article><h3 id="Utilities-for-matrices-(replace-by-available-functions,-or-document-elsewhere?)"><a class="docs-heading-anchor" href="#Utilities-for-matrices-(replace-by-available-functions,-or-document-elsewhere?)">Utilities for matrices (replace by available functions, or document elsewhere?)</a><a id="Utilities-for-matrices-(replace-by-available-functions,-or-document-elsewhere?)-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities-for-matrices-(replace-by-available-functions,-or-document-elsewhere?)" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="pol_elementary_divisors-Union{Tuple{MatElem{T}}, Tuple{T}} where T" href="#pol_elementary_divisors-Union{Tuple{MatElem{T}}, Tuple{T}} where T"><code>pol_elementary_divisors</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pol_elementary_divisors(x::MatElem)
pol_elementary_divisors(x::MatrixGroupElem)</code></pre><p>Return a list of pairs <code>(f_i,m_i)</code>, for irreducible polynomials <code>f_i</code> and positive integers <code>m_i</code>, where the <code>f_i^m_i</code> are the elementary divisors of <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/linear_isconjugate.jl#L80-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="generalized_jordan_block-Union{Tuple{T}, Tuple{T,Int64}} where T&lt;:PolyElem" href="#generalized_jordan_block-Union{Tuple{T}, Tuple{T,Int64}} where T&lt;:PolyElem"><code>generalized_jordan_block</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">generalized_jordan_block(f::T, n::Int) where T&lt;:PolyElem</code></pre><p>Return the Jordan block of dimension <code>n</code> corresponding to the polynomial <code>f</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/linear_isconjugate.jl#L108-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="generalized_jordan_form-Union{Tuple{MatElem{T}}, Tuple{T}} where T" href="#generalized_jordan_form-Union{Tuple{MatElem{T}}, Tuple{T}} where T"><code>generalized_jordan_form</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">generalized_jordan_form(A::MatElem{T}; with_pol=false) where T</code></pre><p>Return (<code>J</code>,<code>Z</code>), where <code>Z^-1*J*Z = A</code> and <code>J</code> is a diagonal join of Jordan blocks (corresponding to irreducible polynomials).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/linear_isconjugate.jl#L125-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="matrix-Union{Tuple{Array{AbstractAlgebra.Generic.FreeModuleElem{T},1}}, Tuple{T}} where T&lt;:FieldElem" href="#matrix-Union{Tuple{Array{AbstractAlgebra.Generic.FreeModuleElem{T},1}}, Tuple{T}} where T&lt;:FieldElem"><code>matrix</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">matrix(A::Array{AbstractAlgebra.Generic.FreeModuleElem{T},1})</code></pre><p>Return the matrix whose rows are the vectors in <code>A</code>. All vectors in <code>A</code> must have the same length and the same base ring.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/matrix_manipulation.jl#L113-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="upper_triangular_matrix-Tuple{Any}" href="#upper_triangular_matrix-Tuple{Any}"><code>upper_triangular_matrix</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">upper_triangular_matrix(L)</code></pre><p>Return the upper triangular matrix whose entries on and above the diagonal are the elements of <code>L</code>.</p><p>An error is returned whenever the length of <code>L</code> is not <code>n*(n+1)/2</code> for some integer <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/matrix_manipulation.jl#L130-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="lower_triangular_matrix-Tuple{Any}" href="#lower_triangular_matrix-Tuple{Any}"><code>lower_triangular_matrix</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lower_triangular_matrix(L)</code></pre><p>Return the upper triangular matrix whose entries on and below the diagonal are the elements of <code>L</code>.</p><p>An error is returned whenever the length of <code>L</code> is not <code>n*(n+1)/2</code> for some integer <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/matrix_manipulation.jl#L152-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="conjugate_transpose-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:FinFieldElem" href="#conjugate_transpose-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:FinFieldElem"><code>conjugate_transpose</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">conjugate_transpose(x::MatElem{T}) where T &lt;: FinFieldElem</code></pre><p>If the base ring of <code>x</code> is <code>GF(q^2)</code>, return the matrix <code>transpose( map ( y -&gt; y^q, x) )</code>.  An error is signalled if the base ring does not have even degree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/matrix_manipulation.jl#L174-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="complement-Union{Tuple{T}, Tuple{AbstractAlgebra.Generic.FreeModule{T},AbstractAlgebra.Generic.Submodule{T}}} where T&lt;:FieldElem" href="#complement-Union{Tuple{T}, Tuple{AbstractAlgebra.Generic.FreeModule{T},AbstractAlgebra.Generic.Submodule{T}}} where T&lt;:FieldElem"><code>complement</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">complement(V::AbstractAlgebra.Generic.FreeModule{T}, W::AbstractAlgebra.Generic.Submodule{T})</code></pre><p>Return a complement for <code>W</code> in <code>V</code>, i.e. a subspace <code>U</code> of <code>V</code> such that <code>V</code> is direct sum of <code>U</code> and <code>W</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/matrix_manipulation.jl#L188-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="permutation_matrix-Union{Tuple{T}, Tuple{AbstractAlgebra.Ring,AbstractArray{T,1}}} where T&lt;:Integer" href="#permutation_matrix-Union{Tuple{T}, Tuple{AbstractAlgebra.Ring,AbstractArray{T,1}}} where T&lt;:Integer"><code>permutation_matrix</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">permutation_matrix(F::Ring, Q::AbstractVector{T}) where T &lt;: Int
permutation_matrix(F::Ring, p::PermGroupElem)</code></pre><p>Return the permutation matrix over the ring <code>R</code> corresponding to the sequence <code>Q</code> or to the permutation <code>p</code>. If <code>Q</code> is a sequence, then <code>Q</code> must contain exactly once every integer from 1 to some <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/matrix_manipulation.jl#L219-L225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="isskewsymmetric_matrix-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:RingElem" href="#isskewsymmetric_matrix-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:RingElem"><code>isskewsymmetric_matrix</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isskewsymmetric_matrix(B::MatElem{T}) where T &lt;: Ring</code></pre><p>Return whether the matrix <code>B</code> is skew-symmetric, i.e. <code>B = -transpose(B)</code> and <code>B</code> has zeros on the diagonal. Returns <code>false</code> if <code>B</code> is not a square matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/matrix_manipulation.jl#L244-L250">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ishermitian_matrix-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:FinFieldElem" href="#ishermitian_matrix-Union{Tuple{MatElem{T}}, Tuple{T}} where T&lt;:FinFieldElem"><code>ishermitian_matrix</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ishermitian_matrix(B::MatElem{T}) where T &lt;: FinFieldElem</code></pre><p>Return whether the matrix <code>B</code> is hermitian, i.e. <code>B = conjugate_transpose(B)</code>. Returns <code>false</code> if <code>B</code> is not a square matrix, or the field has not even degree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/matrix_manipulation.jl#L265-L270">source</a></section></article><h3 id="Classical-groups"><a class="docs-heading-anchor" href="#Classical-groups">Classical groups</a><a id="Classical-groups-1"></a><a class="docs-heading-anchor-permalink" href="#Classical-groups" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="general_linear_group-Tuple{Int64,AbstractAlgebra.Ring}" href="#general_linear_group-Tuple{Int64,AbstractAlgebra.Ring}"><code>general_linear_group</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">general_linear_group(n::Int, q::Int)
general_linear_group(n::Int, F::FqNmodFiniteField)
GL = general_linear_group</code></pre><p>Return the general linear group of dimension <code>n</code> either over the field <code>F</code> or the field <code>GF(q)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/MatGrp.jl#L520-L526">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="special_linear_group-Tuple{Int64,AbstractAlgebra.Ring}" href="#special_linear_group-Tuple{Int64,AbstractAlgebra.Ring}"><code>special_linear_group</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">special_linear_group(n::Int, q::Int)
special_linear_group(n::Int, F::FqNmodFiniteField)
SL = special_linear_group</code></pre><p>Return the special linear group of dimension <code>n</code> either over the field <code>F</code> or the field <code>GF(q)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/MatGrp.jl#L539-L545">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="symplectic_group-Tuple{Int64,AbstractAlgebra.Ring}" href="#symplectic_group-Tuple{Int64,AbstractAlgebra.Ring}"><code>symplectic_group</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">symplectic_group(n::Int, q::Int)
symplectic_group(n::Int, F::FqNmodFiniteField)
Sp = symplectic_group</code></pre><p>Return the symplectic group of dimension <code>n</code> either over the field <code>F</code> or the field <code>GF(q)</code>. The dimension <code>n</code> must be even.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/MatGrp.jl#L558-L564">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="orthogonal_group-Tuple{Int64,Int64,AbstractAlgebra.Ring}" href="#orthogonal_group-Tuple{Int64,Int64,AbstractAlgebra.Ring}"><code>orthogonal_group</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">orthogonal_group(e::Int, n::Int, F::Ring)
orthogonal_group(e::Int, n::Int, q::Int)
GO = orthogonal_group</code></pre><p>Return the orthogonal group of dimension <code>n</code> either over the field <code>F</code> or the field <code>GF(q)</code> of type <code>e</code>, where <code>e</code> in {<code>+1</code>,<code>-1</code>} for <code>n</code> even and <code>e</code>=<code>0</code> for <code>n</code> odd. If <code>n</code> is odd, <code>e</code> can be omitted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/MatGrp.jl#L578-L584">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="special_orthogonal_group-Tuple{Int64,Int64,AbstractAlgebra.Ring}" href="#special_orthogonal_group-Tuple{Int64,Int64,AbstractAlgebra.Ring}"><code>special_orthogonal_group</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">special_orthogonal_group(e::Int, n::Int, F::Ring)
special_orthogonal_group(e::Int, n::Int, q::Int)
SO = special_orthogonal_group</code></pre><p>Return the special orthogonal group of dimension <code>n</code> either over the field <code>F</code> or the field <code>GF(q)</code> of type <code>e</code>, where <code>e</code> in {<code>+1</code>,<code>-1</code>} for <code>n</code> even and <code>e</code>=<code>0</code> for <code>n</code> odd. If <code>n</code> is odd, <code>e</code> can be omitted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/MatGrp.jl#L613-L619">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="omega_group-Tuple{Int64,Int64,AbstractAlgebra.Ring}" href="#omega_group-Tuple{Int64,Int64,AbstractAlgebra.Ring}"><code>omega_group</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">omega_group(e::Int, n::Int, F::Ring)
omega_group(e::Int, n::Int, q::Int)</code></pre><p>Return the Omega group of dimension <code>n</code> over the field <code>GF(q)</code> of type <code>e</code>, where <code>e</code> in {<code>+1</code>,<code>-1</code>} for <code>n</code> even and <code>e</code>=<code>0</code> for <code>n</code> odd. If <code>n</code> is odd, <code>e</code> can be omitted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/MatGrp.jl#L649-L654">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="unitary_group-Tuple{Int64,Int64}" href="#unitary_group-Tuple{Int64,Int64}"><code>unitary_group</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">unitary_group(n::Int, q::Int)
GU = unitary_group</code></pre><p>Return the unitary group of dimension <code>n</code> over the field <code>GF(q^2)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/MatGrp.jl#L684-L689">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="special_unitary_group-Tuple{Int64,Int64}" href="#special_unitary_group-Tuple{Int64,Int64}"><code>special_unitary_group</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">special_unitary_group(n::Int, q::Int)
SU = special_unitary_group</code></pre><p>Return the special unitary group of dimension <code>n</code> over the field <code>GF(q^2)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/MatGrp.jl#L698-L703">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="matrix_group-Union{Tuple{AbstractArray{T,1}}, Tuple{T}} where T&lt;:Union{MatElem, MatrixGroupElem}" href="#matrix_group-Union{Tuple{AbstractArray{T,1}}, Tuple{T}} where T&lt;:Union{MatElem, MatrixGroupElem}"><code>matrix_group</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">matrix_group(V::T...) where T&lt;:MatrixGroup
matrix_group(V::AbstractVector{T}) where T&lt;:MatrixGroup</code></pre><p>Return the matrix group generated by elements in the vector <code>V</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/matrices/MatGrp.jl#L721-L726">source</a></section></article><h2 id="Group-homomorphisms"><a class="docs-heading-anchor" href="#Group-homomorphisms">Group homomorphisms</a><a id="Group-homomorphisms-1"></a><a class="docs-heading-anchor-permalink" href="#Group-homomorphisms" title="Permalink"></a></h2><p>In Oscar, a group homomorphism from <code>G</code> to <code>H</code> is an object of parametric type <code>GAPGroupHomomorphism{S,T}</code>, where <code>S</code> and <code>T</code> are the types of <code>G</code> and <code>H</code> respectively.</p><p>A homomorphism from <code>G</code> to <code>H</code> can be defined in two ways.</p><ul><li>Writing explicitly the images of the generators of <code>G</code>:</li></ul><pre><code class="language-julia">f = hom(G,H,[x1,x2,...],[y1,y2,...])</code></pre><p>Here, <code>[x1,x2,...]</code> must be a generating set for <code>G</code> (not necessarily minimal) and <code>[y1,y2,...]</code> is a vector of elements of <code>H</code> of the same length of <code>[x1,x2,...]</code>. This assigns to <code>f</code> the value of the group homomorphism sending <code>x_i</code> into <code>y_i</code>. If such a homomorphism does not exist, an error is returned.</p><ul><li>Taking an existing function <code>g</code> satisfying the group homomorphism properties:</li></ul><pre><code class="language-julia">f = hom(G,H,g)</code></pre><p>If the function <code>g</code> does not satisfy the group homomorphism properties, an error is returned.</p><p><strong>Example:</strong> The following procedures define the same homomorphism (conjugation by <code>x</code>) in the two ways explained above.</p><pre><code class="language-julia-repl">julia&gt; S=symmetric_group(4);

julia&gt; x=S[1];

julia&gt; f=hom(S,S,gens(S),[S[1]^x,S[2]^x]);

julia&gt; g=hom(S,S,y-&gt;y^x);

julia&gt; f==g
true</code></pre><article class="docstring"><header><a class="docstring-binding" id="hom-Tuple{Oscar.GAPGroup,Oscar.GAPGroup,Function}" href="#hom-Tuple{Oscar.GAPGroup,Oscar.GAPGroup,Function}"><code>hom</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hom(G::GAPGroup, H::GAPGroup, f::Function)</code></pre><p>Return the group homomorphism defined by the function <span>$f$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/homomorphisms.jl#L94-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="hom-Tuple{Oscar.GAPGroup,Oscar.GAPGroup,Array{T,1} where T,Array{T,1} where T}" href="#hom-Tuple{Oscar.GAPGroup,Oscar.GAPGroup,Array{T,1} where T,Array{T,1} where T}"><code>hom</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hom(G::GAPGroup, H::GAPGroup, gensG::Vector, imgs::Vector)</code></pre><p>Return the group homomorphism defined by <code>gensG</code>[<code>i</code>] -&gt; <code>imgs</code>[<code>i</code>] for every <code>i</code>. In order to work, the elements of <code>gensG</code> must generate <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/homomorphisms.jl#L113-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="image-Tuple{GAPGroupHomomorphism,GAPGroupElem}" href="#image-Tuple{GAPGroupHomomorphism,GAPGroupElem}"><code>image</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">image(f::GAPGroupHomomorphism, x::GAPGroupElem)
(f::GAPGroupHomomorphism)(x::GAPGroupElem)</code></pre><p>Return <code>f</code>(<code>x</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/homomorphisms.jl#L147-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="restrict_homomorphism-Tuple{GAPGroupHomomorphism,Oscar.GAPGroup}" href="#restrict_homomorphism-Tuple{GAPGroupHomomorphism,Oscar.GAPGroup}"><code>restrict_homomorphism</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">restrict_homomorphism(f::GAPGroupHomomorphism, H::Group)
restrict_homomorphism(f::GAPGroupElem{AutomorphismGroup{T}}, H::T) where T &lt;: Group</code></pre><p>Return the restriction of <code>f</code> to <code>H</code>; otherwise it return ERROR.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/homomorphisms.jl#L206-L211">source</a></section></article><p>Oscar has also the following standard homomorphism.</p><article class="docstring"><header><a class="docstring-binding" id="id_hom" href="#id_hom"><code>id_hom</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">id_hom(G::GAPGroup)</code></pre><p>Return the identity homomorphism on the group <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/homomorphisms.jl#L68-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="trivial_morphism" href="#trivial_morphism"><code>trivial_morphism</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">trivial_morphism(G::GAPGroup, H::GAPGroup)</code></pre><p>Return the homomorphism from <code>G</code> to <code>H</code> sending every element of <code>G</code> into the identity of <code>H</code>. If <code>H</code> is not specified, it is taken equal to <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/homomorphisms.jl#L77-L81">source</a></section></article><p>To evaluate the homomorphism <code>f</code> in the element <code>x</code> of <code>G</code>, it is possible to use the instruction</p><pre><code class="language-julia">image(f,x)</code></pre><p>or the more compact notations <code>f(x)</code> and <code>x^f</code>.</p><p><strong>Example:</strong></p><pre><code class="language-julia-repl">julia&gt; S=symmetric_group(4);

julia&gt; f=hom(S,S,x-&gt;x^S[1]);

julia&gt; x=cperm(S,[1,2]);

julia&gt; image(f,x)
(2,3)

julia&gt; f(x)
(2,3)

julia&gt; x^f
(2,3)</code></pre><p>A sort of &quot;inverse&quot; of the evaluation is the following</p><article class="docstring"><header><a class="docstring-binding" id="haspreimage-Tuple{GAPGroupHomomorphism,GAPGroupElem}" href="#haspreimage-Tuple{GAPGroupHomomorphism,GAPGroupElem}"><code>haspreimage</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">haspreimage(f::GAPGroupHomomorphism, x::GAPGroupElem)</code></pre><p>Return (<code>true</code>,<code>y</code>) if there exists <code>y</code> such that <code>f</code>(<code>y</code>) = <code>x</code>; otherwise, return (<code>false</code>,<code>1</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/homomorphisms.jl#L268-L272">source</a></section></article><p><strong>Example:</strong></p><pre><code class="language-julia-repl">julia&gt; S=symmetric_group(4);

julia&gt; f=hom(S,S,x-&gt;x^S[1]);

julia&gt; x=cperm(S,[1,2]);

julia&gt; haspreimage(f,x)
(true, (1,4))</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Do not confuse <code>haspreimage</code> with the function <code>has_preimage</code>, which works on variable of type <code>GrpGenToGrpGenMor</code>.</p></div></div><p>A further function that produces isomorphisms is <code>isisomorphic</code>:</p><article class="docstring"><header><a class="docstring-binding" id="isisomorphic-Tuple{Oscar.GAPGroup,Oscar.GAPGroup}" href="#isisomorphic-Tuple{Oscar.GAPGroup,Oscar.GAPGroup}"><code>isisomorphic</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isisomorphic(G::Group, H::Group)</code></pre><p>Return (<code>true</code>,<code>f</code>) if <code>G</code> and <code>H</code> are isomorphic groups, where <code>f</code> is a group isomorphism. Otherwise, return (<code>false</code>,<code>f</code>), where <code>f</code> is the trivial homomorphism.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/homomorphisms.jl#L299-L303">source</a></section></article><h3 id="Operations-on-homomorphisms"><a class="docs-heading-anchor" href="#Operations-on-homomorphisms">Operations on homomorphisms</a><a id="Operations-on-homomorphisms-1"></a><a class="docs-heading-anchor-permalink" href="#Operations-on-homomorphisms" title="Permalink"></a></h3><p>Oscar supports the following operations on homomorphisms.</p><ul><li><p><code>inv(f)</code> = the inverse of <code>f</code>. An error is returned if <code>f</code> is not bijective.</p></li><li><p><code>f^n</code> = the homomorphism <code>f</code> composed <code>n</code> times with itself. An error is returned if the domain and the codomain of <code>f</code> do not coincide (unless <code>n=1</code>). If <code>n</code> is negative, the result is the inverse of <code>f</code> composed <code>n</code> times with itself.</p></li><li><p><code>compose(g,f)</code> = composition of <code>g</code> and <code>f</code>. This works only if the codomain of <code>g</code> coincide with the domain of <code>f</code>. Shorter equivalent expressions are <code>g*f</code> and <code>f(g)</code>.</p><p><strong>Example:</strong></p></li></ul><pre><code class="language-julia-repl">julia&gt; S=symmetric_group(4);

julia&gt; f=hom(S,S,x-&gt;x^S[1]);

julia&gt; g=hom(S,S,x-&gt;x^S[2]);

julia&gt; f*g==hom(S,S,x-&gt;x^(S[1]*S[2]))
true

julia&gt; f==f^-3
true</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The composition operation <code>*</code> has to be read from the right to the left. So, <code>(f*g)(x)</code> is equivalent to <code>g(f(x))</code>.</p></div></div><h3 id="Properties-of-homomorphisms"><a class="docs-heading-anchor" href="#Properties-of-homomorphisms">Properties of homomorphisms</a><a id="Properties-of-homomorphisms-1"></a><a class="docs-heading-anchor-permalink" href="#Properties-of-homomorphisms" title="Permalink"></a></h3><p>Oscar implements the following attributes of homomorphisms.</p><article class="docstring"><header><a class="docstring-binding" id="domain" href="#domain"><code>domain</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">domain(f::GAPGroupHomomorphism)</code></pre><p>Return the domain of <code>f</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/homomorphisms.jl#L126-L130">source</a></section><section><div><pre><code class="language-julia">function domain(F::AlgHom)</code></pre><p>Return the domain of <code>F</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Rings/affine-algebra-homs.jl#L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="codomain" href="#codomain"><code>codomain</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">codomain(f::GAPGroupHomomorphism)</code></pre><p>Return the codomain of <code>f</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/homomorphisms.jl#L135-L139">source</a></section><section><div><pre><code class="language-julia">function codomain(F::AlgHom)</code></pre><p>Return the codomain of <code>F</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Rings/affine-algebra-homs.jl#L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="isinjective-Tuple{GAPGroupHomomorphism}" href="#isinjective-Tuple{GAPGroupHomomorphism}"><code>isinjective</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isinjective(f::GAPGroupHomomorphism)</code></pre><p>Return whether <code>f</code> is injective.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/homomorphisms.jl#L166-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="issurjective-Tuple{GAPGroupHomomorphism}" href="#issurjective-Tuple{GAPGroupHomomorphism}"><code>issurjective</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">issurjective(f::GAPGroupHomomorphism)</code></pre><p>Return whether <code>f</code> is surjective.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/homomorphisms.jl#L157-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="isbijective-Tuple{GAPGroupHomomorphism}" href="#isbijective-Tuple{GAPGroupHomomorphism}"><code>isbijective</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isbijective(f::GAPGroupHomomorphism)</code></pre><p>Return whether <code>f</code> is bijective.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/homomorphisms.jl#L184-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="isinvertible-Tuple{GAPGroupHomomorphism}" href="#isinvertible-Tuple{GAPGroupHomomorphism}"><code>isinvertible</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isinvertible(f::GAPGroupHomomorphism)</code></pre><p>Return whether <code>f</code> is invertible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/homomorphisms.jl#L175-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="isinvariant-Tuple{GAPGroupHomomorphism,Oscar.GAPGroup}" href="#isinvariant-Tuple{GAPGroupHomomorphism,Oscar.GAPGroup}"><code>isinvariant</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isinvariant(f::GAPGroupHomomorphism, H::Group)
isinvariant(f::GAPGroupElem{AutomorphismGroup{T}}, H::T)</code></pre><p>Return whether <code>f</code>(<code>H</code>) == <code>H</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/homomorphisms.jl#L194-L199">source</a></section></article><h3 id="Subgroups-described-by-homomorphisms"><a class="docs-heading-anchor" href="#Subgroups-described-by-homomorphisms">Subgroups described by homomorphisms</a><a id="Subgroups-described-by-homomorphisms-1"></a><a class="docs-heading-anchor-permalink" href="#Subgroups-described-by-homomorphisms" title="Permalink"></a></h3><p>The following functions compute subgroups or quotients of either the domain or the codomain. Analogously to the functions described in Sections <a href="#subgroups">Subgroups</a> and <a href="#quotient">Quotients</a>, the output consists of a pair (<code>H</code>, <code>g</code>), where <code>H</code> is a subgroup (resp. quotient) and <code>g</code> is its embedding (resp. projection) homomorphism.</p><article class="docstring"><header><a class="docstring-binding" id="kernel-Tuple{GAPGroupHomomorphism}" href="#kernel-Tuple{GAPGroupHomomorphism}"><code>kernel</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">kernel(f::GAPGroupHomomorphism)</code></pre><p>Return the kernel of <code>f</code>, together with its embedding into <code>domain</code>(<code>f</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/homomorphisms.jl#L223-L227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="image-Tuple{GAPGroupHomomorphism}" href="#image-Tuple{GAPGroupHomomorphism}"><code>image</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">image(f::GAPGroupHomomorphism)</code></pre><p>Return the image of <code>f</code> as subgroup of <code>codomain</code>(<code>f</code>), together with the embedding homomorphism.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/homomorphisms.jl#L233-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="image-Union{Tuple{S}, Tuple{T}, Tuple{GAPGroupHomomorphism{S,T},S}} where S&lt;:Oscar.GAPGroup where T&lt;:Oscar.GAPGroup" href="#image-Union{Tuple{S}, Tuple{T}, Tuple{GAPGroupHomomorphism{S,T},S}} where S&lt;:Oscar.GAPGroup where T&lt;:Oscar.GAPGroup"><code>image</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">image(f::GAPGroupHomomorphism{S, T}, H::S) where S &lt;: GAPGroup where T &lt;: GAPGroup
(f::GAPGroupHomomorphism{S, T})(H::S)</code></pre><p>Return <code>f</code>(<code>H</code>), together with the embedding homomorphism into <code>codomain</code>(<code>f</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/homomorphisms.jl#L243-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="cokernel-Tuple{GAPGroupHomomorphism}" href="#cokernel-Tuple{GAPGroupHomomorphism}"><code>cokernel</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cokernel(f::GAPGroupHomomorphism)</code></pre><p>Return the cokernel of <code>f</code>, that is, the quotient of the codomain of <code>f</code> by the normal closure of the image.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/homomorphisms.jl#L256-L261">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="preimage-Union{Tuple{S}, Tuple{T}, Tuple{GAPGroupHomomorphism{S,T},T}} where S&lt;:Oscar.GAPGroup where T&lt;:Oscar.GAPGroup" href="#preimage-Union{Tuple{S}, Tuple{T}, Tuple{GAPGroupHomomorphism{S,T},T}} where S&lt;:Oscar.GAPGroup where T&lt;:Oscar.GAPGroup"><code>preimage</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">preimage(f::GAPGroupHomomorphism{S, T}, H::T) where S &lt;: GAPGroup where T &lt;: GAPGroup</code></pre><p>If <code>H</code> is a subgroup of the codomain of <code>f</code>, return the subgroup <code>f^-1(H)</code>, together with its embedding homomorphism into the domain of <code>f</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/homomorphisms.jl#L282-L286">source</a></section></article><h3 id="Groups-created-by-isomorphisms"><a class="docs-heading-anchor" href="#Groups-created-by-isomorphisms">Groups created by isomorphisms</a><a id="Groups-created-by-isomorphisms-1"></a><a class="docs-heading-anchor-permalink" href="#Groups-created-by-isomorphisms" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="isomorphic_perm_group-Tuple{Oscar.GAPGroup}" href="#isomorphic_perm_group-Tuple{Oscar.GAPGroup}"><code>isomorphic_perm_group</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isomorphic_perm_group(G::GAPGroup)</code></pre><p>Return a permutation group <code>H</code> and an isomorphism <code>f</code> from <code>G</code> to <code>H</code>.</p><p>If <code>G</code> is infinite, then no such isomorphism exists and an exception is thrown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/homomorphisms.jl#L313-L319">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="isomorphic_pc_group-Tuple{Oscar.GAPGroup}" href="#isomorphic_pc_group-Tuple{Oscar.GAPGroup}"><code>isomorphic_pc_group</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isomorphic_pc_group(G::GAPGroup)</code></pre><p>Return a group <code>H</code> of type <code>PcGroup</code> and an isomorphism <code>f</code> from <code>G</code> to <code>H</code>.</p><p>If <code>G</code> is infinite or not solvable, then no such isomorphism exists and an exception is thrown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/homomorphisms.jl#L329-L335">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="isomorphic_fp_group-Tuple{Oscar.GAPGroup}" href="#isomorphic_fp_group-Tuple{Oscar.GAPGroup}"><code>isomorphic_fp_group</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isomorphic_fp_group(G::GAPGroup)</code></pre><p>Return a group <code>H</code> of type <code>FPGroup</code> and an isomorphism <code>f</code> from <code>G</code> to <code>H</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/homomorphisms.jl#L343-L347">source</a></section></article><h2 id="Groups-of-automorphisms"><a class="docs-heading-anchor" href="#Groups-of-automorphisms">Groups of automorphisms</a><a id="Groups-of-automorphisms-1"></a><a class="docs-heading-anchor-permalink" href="#Groups-of-automorphisms" title="Permalink"></a></h2><p>Groups of automorphisms over a group <code>G</code> have parametric type <code>AutomorphismGroup{T}</code>, where <code>T</code> is the type of <code>G</code>. The group of automorphisms over a group <code>G</code> is defined by the following instruction:</p><pre><code class="language-julia">AutomorphismGroup{T}
automorphism_group(G)</code></pre><p>The evaluation of the automorphism <code>f</code> in the element <code>x</code> is analogous to the homomorphism evaluation: it can be obtained by typing either <code>f(x)</code> or <code>x^f</code>.</p><p>It is possible to turn an automorphism <code>f</code> into a homomorphism by typing <code>hom(f)</code>. The viceversa is also possible: if <code>g</code> is a bijective homomorphism from the group <code>G</code> to itself and <code>A</code> is the automorphism group of <code>G</code>, then the instruction <code>A(g)</code> returns <code>g</code> as automorphism of <code>G</code>. This is the standard way to build explicitly an automorphism (another way, available for inner automorphisms, is shown in Section <a href="#inner_automorphisms">Inner_automorphisms</a>).</p><article class="docstring"><header><a class="docstring-binding" id="automorphism_group-Tuple{Oscar.GAPGroup}" href="#automorphism_group-Tuple{Oscar.GAPGroup}"><code>automorphism_group</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">automorphism_group(G::Group) -&gt; A::AutomorphismGroup{T}</code></pre><p>Return the full automorphism group of <code>G</code>. If <code>f</code> is an object of type <span>$GAPGroupHomomorphism$</span> and it is bijective from <code>G</code> to itself, then <code>A(f)</code> return the embedding of <code>f</code> in <code>A</code>. </p><p>Elements of <code>A</code> can be multiplied with other elements of <code>A</code> or by elements of type <code>GAPGroupHomomorphism</code>; in this last case, the result has type <code>GAPGroupHomomorphism</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/homomorphisms.jl#L362-L370">source</a></section></article><p><strong>Example:</strong></p><pre><code class="language-julia-repl">julia&gt; S=symmetric_group(4);

julia&gt; A=automorphism_group(S);

julia&gt; g=hom(S,S,x-&gt;x^S[1]);

julia&gt; g in A
false

julia&gt; au=A(g);

julia&gt; au in A
true

julia&gt; g==hom(au)
true

julia&gt; x=cperm(S,[1,2,3]);

julia&gt; au(x)
(2,3,4)

julia&gt; g(x)==au(x)
true</code></pre><p>In Oscar it is possible to multiply homomorphisms and automorphisms (whenever it makes sense); in such cases, the output is always a variable of type <code>GAPGroupHomomorphism{S,T}</code>.</p><pre><code class="language-julia-repl">julia&gt; S=symmetric_group(4);

julia&gt; A=automorphism_group(S);

julia&gt; g=hom(S,S,x-&gt;x^S[1]);

julia&gt; f=A(g);

julia&gt; typeof(g*f)
GAPGroupHomomorphism{PermGroup,PermGroup}</code></pre><p>The following functions are available for automorphisms, some of them similar to the corresponding functions for homomorphisms of groups.</p><article class="docstring"><header><a class="docstring-binding" id="isinvariant-Union{Tuple{T}, Tuple{GAPGroupElem{AutomorphismGroup{T}},T}} where T&lt;:Oscar.GAPGroup" href="#isinvariant-Union{Tuple{T}, Tuple{GAPGroupElem{AutomorphismGroup{T}},T}} where T&lt;:Oscar.GAPGroup"><code>isinvariant</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isinvariant(f::GAPGroupElem{AutomorphismGroup{T}}, H::T)</code></pre><p>Return whether <code>f</code>(<code>H</code>) == <code>H</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/homomorphisms.jl#L447-L451">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="restrict_automorphism-Union{Tuple{T}, Tuple{GAPGroupElem{AutomorphismGroup{T}},T}, Tuple{GAPGroupElem{AutomorphismGroup{T}},T,Any}} where T&lt;:Oscar.GAPGroup" href="#restrict_automorphism-Union{Tuple{T}, Tuple{GAPGroupElem{AutomorphismGroup{T}},T}, Tuple{GAPGroupElem{AutomorphismGroup{T}},T,Any}} where T&lt;:Oscar.GAPGroup"><code>restrict_automorphism</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">restrict_automorphism(f::GAPGroupElem{AutomorphismGroup{T}}, H::T)</code></pre><p>If <code>H</code> is invariant under <code>f</code>, returns the restriction of <code>f</code> to <code>H</code> as automorphism of <code>H</code>; otherwise it returns ERROR.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/homomorphisms.jl#L472-L476">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="induced_automorphism-Tuple{GAPGroupHomomorphism,GAPGroupHomomorphism}" href="#induced_automorphism-Tuple{GAPGroupHomomorphism,GAPGroupHomomorphism}"><code>induced_automorphism</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">induced_automorphism(f::GAPGroupHomomorphism, g::GAPGroupHomomorphism)
induced_automorphism(f::GAPGroupHomomorphism, g::GAPGroupElem{AutomorphismGroup{T}})</code></pre><p>Return the automorphism <code>h</code> of the image of <code>f</code> such that <code>h</code>(<code>f</code>) == <code>f</code>(<code>g</code>), where <code>g</code> is an automorphism of a group <code>G</code> and <code>f</code> is a group homomorphism defined over <code>G</code> such that the kernel of <code>f</code> is invariant under <code>g</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/homomorphisms.jl#L457-L462">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="hom-Union{Tuple{GAPGroupElem{AutomorphismGroup{T}}}, Tuple{T}} where T&lt;:Oscar.GAPGroup" href="#hom-Union{Tuple{GAPGroupElem{AutomorphismGroup{T}}}, Tuple{T}} where T&lt;:Oscar.GAPGroup"><code>hom</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hom(f::GAPGroupElem{AutomorphismGroup{T}}) where T</code></pre><p>Return the element f of type <span>$GAPGroupHomomorphism{T,T}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/homomorphisms.jl#L380-L384">source</a></section></article><h3 id="inner_automorphisms"><a class="docs-heading-anchor" href="#inner_automorphisms">Inner automorphisms</a><a id="inner_automorphisms-1"></a><a class="docs-heading-anchor-permalink" href="#inner_automorphisms" title="Permalink"></a></h3><p>Oscar disposes of the following functions to handle inner automorphisms of a group.</p><article class="docstring"><header><a class="docstring-binding" id="inner_automorphism-Tuple{GAPGroupElem}" href="#inner_automorphism-Tuple{GAPGroupElem}"><code>inner_automorphism</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inner_automorphism(g::GAPGroupElem)</code></pre><p>Return the inner automorphism in <code>automorphism_group(parent(g))</code> defined by <code>x</code> -&gt; <code>x^g</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/homomorphisms.jl#L413-L417">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="isinner_automorphism-Tuple{GAPGroupHomomorphism}" href="#isinner_automorphism-Tuple{GAPGroupHomomorphism}"><code>isinner_automorphism</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isinner_automorphism(f::GAPGroupHomomorphism)
isinner_automorphism(f::GAPGroupElem{AutomorphismGroup{T}})</code></pre><p>Return whether <code>f</code> is an inner automorphism.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/homomorphisms.jl#L422-L427">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="inner_automorphisms_group-Union{Tuple{AutomorphismGroup{T}}, Tuple{T}} where T&lt;:Oscar.GAPGroup" href="#inner_automorphisms_group-Union{Tuple{AutomorphismGroup{T}}, Tuple{T}} where T&lt;:Oscar.GAPGroup"><code>inner_automorphisms_group</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inner_automorphisms_group(A::AutomorphismGroup{T})</code></pre><p>Return the subgroup of <code>A</code> of the inner automorphisms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/homomorphisms.jl#L437-L441">source</a></section></article><h2 id="Group-libraries"><a class="docs-heading-anchor" href="#Group-libraries">Group libraries</a><a id="Group-libraries-1"></a><a class="docs-heading-anchor-permalink" href="#Group-libraries" title="Permalink"></a></h2><h3 id="Transitive-permutation-groups-of-small-degree"><a class="docs-heading-anchor" href="#Transitive-permutation-groups-of-small-degree">Transitive permutation groups of small degree</a><a id="Transitive-permutation-groups-of-small-degree-1"></a><a class="docs-heading-anchor-permalink" href="#Transitive-permutation-groups-of-small-degree" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="number_transitive_groups" href="#number_transitive_groups"><code>number_transitive_groups</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">number_transitive_groups(n::Int)</code></pre><p>Return the number of transitive groups acting on a set of size <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/libraries/transitivegroups.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="transitive_group" href="#transitive_group"><code>transitive_group</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">transitive_group(deg::Int, i::Int)</code></pre><p>Return the <code>i</code>-th group in the catalogue of transitive groups over the set {<code>1</code>,...,<code>deg</code>} in the GAP Small Groups Library. The output is a group of type <span>$PermGroup$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/libraries/transitivegroups.jl#L15-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="transitive_identification" href="#transitive_identification"><code>transitive_identification</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">transitive_identification(G::PermGroup)</code></pre><p>Return (<code>deg</code>, <code>m</code>), where <code>G</code> = transitive_group(<code>deg</code>,<code>m</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/libraries/transitivegroups.jl#L25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="all_transitive_groups" href="#all_transitive_groups"><code>all_transitive_groups</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">all_transitive_groups(L...)</code></pre><p>Return the list of all transitive groups (up to isomorphism) satisfying the conditions in <code>L</code>. Here, <code>L</code> is a vector whose arguments are organized as <code>L</code> = [ <code>func1</code>, <code>arg1</code>, <code>func2</code>, <code>arg2</code>, ... ], and the function returns all the groups <code>G</code> satisfying the conditions <code>func1</code>(<code>G</code>) = <code>arg1</code>, <code>func2</code>(<code>G</code>) = <code>arg2</code>, etc. An argument can be omitted if it corresponds to the boolean value <span>$true$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; all_transitive_groups(degree, 4, isabelian)
2-element Array{PermGroup,1}:
 C(4) = 4
 E(4) = 2[x]2</code></pre><p>returns the list of all abelian transitive groups acting on a set of order 4.</p><p>The type of the groups is <span>$PermGroup$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/libraries/transitivegroups.jl#L32-L47">source</a></section></article><h3 id="Primitive-permutation-groups-of-small-degree"><a class="docs-heading-anchor" href="#Primitive-permutation-groups-of-small-degree">Primitive permutation groups of small degree</a><a id="Primitive-permutation-groups-of-small-degree-1"></a><a class="docs-heading-anchor-permalink" href="#Primitive-permutation-groups-of-small-degree" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="number_primitive_groups" href="#number_primitive_groups"><code>number_primitive_groups</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">number_primitive_groups(n::Int)</code></pre><p>Return the number of primitive groups acting on a set of size <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/libraries/primitivegroups.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="primitive_group" href="#primitive_group"><code>primitive_group</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">primitive_group(deg::Int, i::Int)</code></pre><p>Return the <code>i</code>-th group in the catalogue of primitive groups over the set {<code>1</code>,...,<code>deg</code>} in the GAP Small Groups Library. The output is a group of type <span>$PermGroup$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/libraries/primitivegroups.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="all_primitive_groups" href="#all_primitive_groups"><code>all_primitive_groups</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">all_primitive_groups(L...)</code></pre><p>Return the list of all primitive groups (up to isomorphism) satisfying the conditions in <code>L</code>. Here, <code>L</code> is a vector whose arguments are organized as <code>L</code> = [ <code>func1</code>, <code>arg1</code>, <code>func2</code>, <code>arg2</code>, ... ], and the function returns all the groups <code>G</code> satisfying the conditions <code>func1</code>(<code>G</code>) = <code>arg1</code>, <code>func2</code>(<code>G</code>) = <code>arg2</code>, etc. An argument can be omitted if it corresponds to the boolean value <span>$true$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; all_primitive_groups(degree, 4, isabelian)
PermGroup[]</code></pre><p>returns the list of all abelian primitive groups acting on a set of order 4.</p><p>The type of the groups is <span>$PermGroup$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/libraries/primitivegroups.jl#L27-L40">source</a></section></article><h3 id="Perfect-groups-of-small-order"><a class="docs-heading-anchor" href="#Perfect-groups-of-small-order">Perfect groups of small order</a><a id="Perfect-groups-of-small-order-1"></a><a class="docs-heading-anchor-permalink" href="#Perfect-groups-of-small-order" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="number_perfect_groups" href="#number_perfect_groups"><code>number_perfect_groups</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">number_perfect_groups(n::Int)</code></pre><p>Return the number of perfect groups of order <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/libraries/perfectgroups.jl#L39-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="perfect_group" href="#perfect_group"><code>perfect_group</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">perfect_group(n::Int, i::Int)
perfect_group(::Type{T}, n::Int, i::Int)</code></pre><p>Return the <code>i</code>-th group of order <code>n</code> and type <code>T</code> in the catalogue of perfect groups in the GAP Small Groups Library. The type <code>T</code> can be either <span>$PermGroup$</span> or <span>$FPGroup$</span>. The group is given of type <span>$FPGroup$</span> if <code>T</code> is not specified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/libraries/perfectgroups.jl#L11-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="perfect_identification" href="#perfect_identification"><code>perfect_identification</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">perfect_identification(G::Group)</code></pre><p>Return (<code>n</code>, <code>m</code>), where <code>G</code> = perfect_group(<code>n</code>,<code>m</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/libraries/perfectgroups.jl#L32-L36">source</a></section></article><h3 id="Groups-of-small-order"><a class="docs-heading-anchor" href="#Groups-of-small-order">Groups of small order</a><a id="Groups-of-small-order-1"></a><a class="docs-heading-anchor-permalink" href="#Groups-of-small-order" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="number_small_groups" href="#number_small_groups"><code>number_small_groups</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">number_small_groups(n::Int)</code></pre><p>Return the number of small groups of order <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/libraries/smallgroups.jl#L36-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="small_group" href="#small_group"><code>small_group</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">small_group(n::Int, i::Int)</code></pre><p>Return the <code>i</code>-th group of order <code>n</code> in the catalogue of the GAP Small Groups Library. The group is given of type <span>$PcGroup$</span> if the group is solvable, <span>$PermGroup$</span> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/libraries/smallgroups.jl#L13-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="small_group_identification" href="#small_group_identification"><code>small_group_identification</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">small_group_identification(G::Group)</code></pre><p>Return (<code>n</code>, <code>m</code>), where <code>G</code> = small_group(<code>n</code>,<code>m</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/libraries/smallgroups.jl#L25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="all_small_groups" href="#all_small_groups"><code>all_small_groups</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">all_small_groups(n::Int, L...)</code></pre><p>Return the list of all groups (up to isomorphism) of order <code>n</code> and satisfying the conditions in <code>L</code>. Here, <code>L</code> is a vector whose arguments are organized as <code>L</code> = [ <code>func1</code>, <code>arg1</code>, <code>func2</code>, <code>arg2</code>, ... ], and the function returns all the groups <code>G</code> satisfying the conditions <code>func1</code>(<code>G</code>) = <code>arg1</code>, <code>func2</code>(<code>G</code>) = <code>arg2</code>, etc. An argument can be omitted if it corresponds to the boolean value <span>$true$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-none">julia&gt; all_small_groups(12, cyclic, false, isabelian)</code></pre><p>returns the list of all abelian non-cyclic groups of order 12.</p><p>The type of the groups is <span>$PcGroup$</span> if the group is solvable, <span>$PermGroup$</span> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/d80f180e5b225a8d1d5b5fc0dcbc16dacb968bd7/src/Groups/libraries/smallgroups.jl#L44-L56">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../Nemo/docs/src/finitefield/">Â« Finite fields</a><a class="docs-footer-nextpage" href="../../Hecke/docs/src/abelian/introduction/">Abelian Groups Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 17 June 2021 11:55">Thursday 17 June 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
