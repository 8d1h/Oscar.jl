<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Orders Â· Oscar.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../../../assets/documenter.js"></script><script src="../../../../../siteinfo.js"></script><script src="../../../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Oscar.jl</span></div><form class="docs-search" action="../../../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../../../">Welcome to Oscar</a></li><li><span class="tocitem">Rings</span><ul><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/rings/">Ring Interface</a></li><li><a class="tocitem" href="../../../../../Rings/integer/">Integers</a></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Univariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/polynomial_rings/">Univariate Polynomial Ring Interface</a></li><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/polynomial/">Generic univariate polynomials</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Multivariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/mpolynomial_rings/">Multivariate Polynomial Ring Interface</a></li><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/mpolynomial/">Generic sparse distributed multivariate polynomials</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-5" type="checkbox" checked/><label class="tocitem" for="menuitem-2-5"><span class="docs-label">Orders</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../introduction/">Introduction</a></li><li class="is-active"><a class="tocitem" href>Orders</a><ul class="internal"><li><a class="tocitem" href="#Creation-and-basic-properties"><span>Creation and basic properties</span></a></li></ul></li><li><a class="tocitem" href="../elements/">Elements</a></li><li><a class="tocitem" href="../ideals/">Ideals</a></li><li><a class="tocitem" href="../frac_ideals/">Fractional ideals</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-6" type="checkbox"/><label class="tocitem" for="menuitem-2-6"><span class="docs-label">Series Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/series_rings/">Series Ring Interface</a></li><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/series/">Generic power series</a></li><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/puiseux/">Generic Puiseux series</a></li><li><a class="tocitem" href="../../../../../Nemo/docs/src/series/">Power series and Laurent series</a></li><li><a class="tocitem" href="../../../../../Nemo/docs/src/puiseux/">Puiseux series</a></li></ul></li></ul></li><li><span class="tocitem">Fields</span><ul><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/fields/">Field Interface</a></li><li><a class="tocitem" href="../../../../../Rings/rational/">Rationals</a></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Number Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../number_fields/intro/">Number Fields</a></li><li><a class="tocitem" href="../../number_fields/basics/">-</a></li><li><a class="tocitem" href="../../number_fields/elements/">-</a></li></ul></li><li><a class="tocitem" href="../../FacElem/">Factored Elements</a></li><li><a class="tocitem" href="../../class_fields/intro/">Class Field Theory</a></li><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/fields/">Field Interface</a></li><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/fraction_fields/">Fraction Field Interface</a></li><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/fraction/">Generic fraction fields</a></li><li><input class="collapse-toggle" id="menuitem-3-9" type="checkbox"/><label class="tocitem" for="menuitem-3-9"><span class="docs-label">Local Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../../Nemo/docs/src/padic/">Padics</a></li><li><a class="tocitem" href="../../../../../Nemo/docs/src/qadic/">Qadics</a></li></ul></li><li><a class="tocitem" href="../../../../../Nemo/docs/src/finitefield/">Finite fields</a></li></ul></li><li><span class="tocitem">Groups</span><ul><li><a class="tocitem" href="../../../../../Groups/groups/">Groups</a></li><li><a class="tocitem" href="../../abelian/introduction/">Abelian Groups</a></li></ul></li><li><span class="tocitem">Linear Algebra</span><ul><li><a class="tocitem" href="../../sparse/intro/">Sparse linear algebra</a></li><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/matrix_spaces/">Matrix Interface</a></li><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/matrix/">Generic matrices</a></li><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/matrix_algebras/">Generic matrix algebras</a></li><li><input class="collapse-toggle" id="menuitem-5-5" type="checkbox"/><label class="tocitem" for="menuitem-5-5"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/module/">Module Interface</a></li><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/free_module/">Free Modules and Vector Spaces</a></li><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/submodule/">Submodules</a></li><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/quotient_module/">Quotient modules</a></li><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/direct_sum/">Direct Sums</a></li><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/module_homomorphism/">Module Homomorphisms</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-6" type="checkbox"/><label class="tocitem" for="menuitem-5-6"><span class="docs-label">Quadratic and Hermitian forms</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../quad_forms/introduction/">Introduction</a></li><li><a class="tocitem" href="../../quad_forms/basics/">Basics</a></li><li><a class="tocitem" href="../../quad_forms/lattices/">Quadratic and hermitian lattices</a></li></ul></li></ul></li><li><span class="tocitem">Commutative Algebra</span><ul><li><a class="tocitem" href="../../../../../CommutativeAlgebra/ca/">Introduction</a></li><li><a class="tocitem" href="../../../../../CommutativeAlgebra/ca_ideals/">Ideals</a></li><li><a class="tocitem" href="../../../../../CommutativeAlgebra/ca_modules/">Modules</a></li><li><a class="tocitem" href="../../../../../CommutativeAlgebra/ca_affine_algebras/">Affine Algebras</a></li><li><a class="tocitem" href="../../../../../CommutativeAlgebra/ca_invariant_theory/">Invariant Theory</a></li></ul></li><li><a class="tocitem" href="../../../../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Rings</a></li><li><a class="is-disabled">Orders</a></li><li class="is-active"><a href>Orders</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Orders</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Orders"><a class="docs-heading-anchor" href="#Orders">Orders</a><a id="Orders-1"></a><a class="docs-heading-anchor-permalink" href="#Orders" title="Permalink"></a></h1><p>Orders, ie. unitary subrings that are free <span>$Z$</span>-modules of rank equal to the degree of the number field, are at the core of the arithmetic of number fields. In Hecke, orders are always represented using the module structure, be it the <span>$Z$</span>-module structure for orders in absolute fields, of the structure as a module over the maximal order of the base field in the case of relative extensions. In this chapter we only deal with orders in absolute fields. There are more general definitions of orders in number fields available, but those are (currently) not implemented in Hecke.</p><p>Among all orders in a fixed field, there is a unique maximal one, called the maximal order, or ring of integers of the field. It is well known that this is the only order that is a Dedekind domain, hence has a rich ideal structure as well. The maximal order is also the integral closure of <span>$Z$</span> in the number field and can also be interpreted as a normalisation of any other order.</p><h2 id="Creation-and-basic-properties"><a class="docs-heading-anchor" href="#Creation-and-basic-properties">Creation and basic properties</a><a id="Creation-and-basic-properties-1"></a><a class="docs-heading-anchor-permalink" href="#Creation-and-basic-properties" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Hecke.Order-Tuple{AnticNumberField,Array{nf_elem,1}}" href="#Hecke.Order-Tuple{AnticNumberField,Array{nf_elem,1}}"><code>Hecke.Order</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Order(B::Array{nf_elem, 1}; check::Bool = true, cached::Bool = true) -&gt; NfOrd</code></pre><p>Returns the order generated by <span>$B$</span>. If <code>check</code> is set, it is checked whether <span>$B$</span> defines an order. If <code>isbasis</code> is set, then elements are assumed to form a <span>$\mathbf{Z}$</span>-basis.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Hecke.Order-Tuple{AnticNumberField,FakeFmpqMat}" href="#Hecke.Order-Tuple{AnticNumberField,FakeFmpqMat}"><code>Hecke.Order</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Order(K::AnticNumberField, A::FakeFmpqMat; check::Bool = true) -&gt; NfOrd</code></pre><p>Returns the order which has basis matrix <span>$A$</span> with respect to the power basis of <span>$K$</span>. If <code>check</code> is set, it is checked whether <span>$A$</span> defines an order.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Hecke.Order-Tuple{Hecke.NfAbsOrdFracIdl{AnticNumberField,nf_elem}}" href="#Hecke.Order-Tuple{Hecke.NfAbsOrdFracIdl{AnticNumberField,nf_elem}}"><code>Hecke.Order</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">  Order(K::NumField, M::PMat) -&gt; NfRelOrd</code></pre><p>Returns the order which has basis pseudo-matrix <span>$M$</span> with respect to the power basis of <span>$K$</span>.</p></div></section><section><div><pre><code class="language-none">Order(K::AnticNumberField, A::fmpz_mat, check::Bool = true) -&gt; NfOrd</code></pre><p>Returns the order which has basis matrix <span>$A$</span> with respect to the power basis of <span>$K$</span>. If <code>check</code> is set, it is checked whether <span>$A$</span> defines an order.</p></div></section><section><div><pre><code class="language-none">Order(A::AbsAlgAss{&lt;: NumFieldElem}, M::PMat{&lt;: NumFieldElem, T})
  -&gt; AlgAssRelOrd</code></pre><p>Returns the order of <span>$A$</span> with basis pseudo-matrix <span>$M$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Hecke.EquationOrder-Tuple{AnticNumberField}" href="#Hecke.EquationOrder-Tuple{AnticNumberField}"><code>Hecke.EquationOrder</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">  EquationOrder(L::NumField) -&gt; NfRelOrd
  equation_order(L::NumField) -&gt; NfRelOrd</code></pre><p>Returns the equation order of the number field <span>$L$</span>.</p></div></section><section><div><pre><code class="language-none">EquationOrder(K::NfAbs) -&gt; NfAbsOrd</code></pre><p>Returns the equation order of the absolute number field <span>$K$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Hecke.MaximalOrder-Tuple{AnticNumberField}" href="#Hecke.MaximalOrder-Tuple{AnticNumberField}"><code>Hecke.MaximalOrder</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">MaximalOrder(K::NumField{fmpq}; discriminant::fmpz, ramified_primes::Vector{fmpz}) -&gt; NfAbsOrd</code></pre><p>Returns the maximal order of <span>$K$</span>. Additional information can be supplied if they are already known, as the ramified primes or the discriminant of the maximal order.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; Qx, x = FlintQQ[&quot;x&quot;];
julia&gt; K, a = NumberField(x^3 + 2, &quot;a&quot;);
julia&gt; O = MaximalOrder(K);</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Hecke.MaximalOrder-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}" href="#Hecke.MaximalOrder-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}"><code>Hecke.MaximalOrder</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">MaximalOrder(O::NfAbsOrd; index_divisors::Vector{fmpz}, discriminant::fmpz, ramified_primes::Vector{fmpz}) -&gt; NfAbsOrd</code></pre><p>Returns the maximal order of the number field that contains <span>$O$</span>. Additional information can be supplied if they are already known, as the ramified primes, the discriminant of the maximal order or a set of integers dividing the index of <span>$O$</span> in the maximal order.</p></div></section><section><div><pre><code class="language-none">MaximalOrder(O::AlgAssAbsOrd)</code></pre><p>Given an order <span>$O$</span>, this function returns a maximal order containing <span>$O$</span>.</p></div></section><section><div><pre><code class="language-none">MaximalOrder(A::AbsAlgAss{fmpq}) -&gt; AlgAssAbsOrd</code></pre><p>Returns a maximal order of <span>$A$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Hecke.maximal_order-Tuple{AnticNumberField}" href="#Hecke.maximal_order-Tuple{AnticNumberField}"><code>Hecke.maximal_order</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">maximal_order(O::AlgAssRelOrd) -&gt; AlgAssRelOrd</code></pre><p>Returns a maximal order of the algebra of <span>$O$</span> containing itself.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.lll-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}" href="#Nemo.lll-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}"><code>Nemo.lll</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lll(M::NfAbsOrd) -&gt; NfAbsOrd</code></pre><p>The same order, but with the basis now being LLL reduced wrt. the Minkowski metric.</p></div></section></article><p>By Chistov&#39;s fundamental theorem, the computation of the maximal order is basically as hard as the factorisation of the discriminant. In order to help the computer, Hecke also provides the following signatures:</p><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>maximal_order(::AnticNumberField, ::Array{fmpz, 1})</code>. Check Documenter&#39;s build log for details.</p></div></div><p>It is also possible the execute the steps individually:</p><article class="docstring"><header><a class="docstring-binding" id="Hecke.pradical-Tuple{NfAbsOrd{AnticNumberField,nf_elem},fmpz}" href="#Hecke.pradical-Tuple{NfAbsOrd{AnticNumberField,nf_elem},fmpz}"><code>Hecke.pradical</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pradical(O::NfOrd, p::{fmpz|Integer}) -&gt; NfAbsOrdIdl</code></pre><p>Given a prime number <span>$p$</span>, this function returns the <span>$p$</span>-radical <span>$\sqrt{p\mathcal O}$</span> of <span>$\mathcal O$</span>, which is just <span>$\{ x \in \mathcal O \mid \exists k \in \mathbf Z_{\geq 0} \colon x^k \in p\mathcal O \}$</span>. It is not checked that <span>$p$</span> is prime.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Hecke.ring_of_multipliers-Tuple{NfAbsOrdIdl{AnticNumberField,nf_elem}}" href="#Hecke.ring_of_multipliers-Tuple{NfAbsOrdIdl{AnticNumberField,nf_elem}}"><code>Hecke.ring_of_multipliers</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ring_of_multipliers(a::NfRelOrdIdl) -&gt; NfRelOrd</code></pre><p>Computes the order <span>$(a : a)$</span>, which is the set of all <span>$x \in K$</span> with <span>$xa \subseteq a$</span>, where <span>$K$</span> is the ambient number field of <span>$a$</span>.</p></div></section><section><div><pre><code class="language-none">ring_of_multipliers(I::NfAbsOrdIdl) -&gt; NfAbsOrd</code></pre><p>Computes the order <span>$(I : I)$</span>, which is the set of all <span>$x \in K$</span> with <span>$xI \subseteq I$</span>.</p></div></section></article><h3 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h3><pre><code class="language-julia-repl">
julia&gt; Qx, x = PolynomialRing(FlintQQ, &quot;x&quot;);

julia&gt; K, a = NumberField(x^2 - 2, &quot;a&quot;);

julia&gt; O = EquationOrder(K)
Order of Number field over Rational Field with defining polynomial x^2 - 2
with Z-basis NfAbsOrdElem{AnticNumberField,nf_elem}[1, a]</code></pre><article class="docstring"><header><a class="docstring-binding" id="Base.parent-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}" href="#Base.parent-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}"><code>Base.parent</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parent(O::NfAbsOrd) -&gt; NfOrdSet</code></pre><p>Returns the parent of <span>$\mathcal O$</span>, that is, the set of orders of the ambient number field.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Hecke.isequation_order-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}" href="#Hecke.isequation_order-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}"><code>Hecke.isequation_order</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isequation_order(O::NfAbsOrd) -&gt; Bool</code></pre><p>Returns whether <span>$\mathcal O$</span> is the equation order of the ambient number field <span>$K$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.signature-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}" href="#Nemo.signature-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}"><code>Nemo.signature</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">signature(O::NfOrd) -&gt; Tuple{Int, Int}</code></pre><p>Returns the signature of the ambient number field of <span>$\mathcal O$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Hecke.nf-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}" href="#Hecke.nf-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}"><code>Hecke.nf</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">  nf(O::NfRelOrd) -&gt; NumField</code></pre><p>Returns the ambient number field of <span>$\mathcal O$</span>.</p></div></section><section><div><pre><code class="language-none">nf(O::NfAbsOrd) -&gt; AnticNumberField</code></pre><p>Returns the ambient number field of <span>$\mathcal O$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.Generic.degree-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}" href="#AbstractAlgebra.Generic.degree-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}"><code>AbstractAlgebra.Generic.degree</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">degree(O::NfOrd) -&gt; Int</code></pre><p>Returns the degree of <span>$\mathcal O$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.Generic.basis-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}" href="#AbstractAlgebra.Generic.basis-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}"><code>AbstractAlgebra.Generic.basis</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">basis(O::NfOrd) -&gt; Array{NfOrdElem, 1}</code></pre><p>Returns the <span>$\mathbf Z$</span>-basis of <span>$\mathcal O$</span>.</p></div></section><section><div><pre><code class="language-julia">basis(I::NfAbsOrdFracIdl) -&gt; Array{nf_elem, 1}</code></pre><p>Returns the <span>$\mathbf Z$</span>-basis of <span>$I$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.Generic.basis-Tuple{NfAbsOrd{AnticNumberField,nf_elem},AnticNumberField}" href="#AbstractAlgebra.Generic.basis-Tuple{NfAbsOrd{AnticNumberField,nf_elem},AnticNumberField}"><code>AbstractAlgebra.Generic.basis</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">basis(O::NfOrd, K::AnticNumberField) -&gt; Array{nf_elem, 1}</code></pre><p>Returns the <span>$\mathbf Z$</span>-basis elements of <span>$\mathcal O$</span> as elements of the ambient number field.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Hecke.basis_matrix-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}" href="#Hecke.basis_matrix-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}"><code>Hecke.basis_matrix</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">basis_matrix(O::NfOrd) -&gt; FakeFmpqMat</code></pre><p>Returns the basis matrix of <span>$\mathcal O$</span> with respect to the power basis of the ambient number field.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Hecke.basis_mat_inv-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}" href="#Hecke.basis_mat_inv-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}"><code>Hecke.basis_mat_inv</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">basis_mat_inv(O::NfOrd) -&gt; FakeFmpqMat</code></pre><p>Returns the inverse of the basis matrix of <span>$\mathcal O$</span>.</p></div></section><section><div><pre><code class="language-none">basis_mat_inv(A::NfAbsOrdIdl) -&gt; fmpz_mat</code></pre><p>Returns the inverse basis matrix of <span>$A$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.Generic.discriminant-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}" href="#AbstractAlgebra.Generic.discriminant-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}"><code>AbstractAlgebra.Generic.discriminant</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">discriminant(O::NfOrd) -&gt; fmpz</code></pre><p>Returns the discriminant of <span>$\mathcal O$</span>.</p></div></section><section><div><pre><code class="language-none">discriminant(B::Array{NfAbsOrdElem, 1}) -&gt; fmpz</code></pre><p>Returns the discriminant of the family <span>$B$</span>.</p></div></section><section><div><pre><code class="language-none">discriminant(E::EllCrv{T}) -&gt; T</code></pre><p>Computes the discriminant of <span>$E$</span>.</p></div></section><section><div><pre><code class="language-none">discriminant(O::AlgssRelOrd)</code></pre><p>Returns the discriminant of <span>$O$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Hecke.gen_index-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}" href="#Hecke.gen_index-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}"><code>Hecke.gen_index</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gen_index(O::NfOrd) -&gt; fmpq</code></pre><p>Returns the generalized index of <span>$\mathcal O$</span> with respect to the equation order of the ambient number field.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Hecke.index-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}" href="#Hecke.index-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}"><code>Hecke.index</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">index(O::NfOrd) -&gt; fmpz</code></pre><p>Assuming that the order <span>$\mathcal O$</span> contains the equation order <span>$\mathbf Z[\alpha]$</span> of the ambient number field, this function returns the index <span>$[ \mathcal O : \mathbf Z]$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Hecke.isindex_divisor-Tuple{NfAbsOrd{AnticNumberField,nf_elem},fmpz}" href="#Hecke.isindex_divisor-Tuple{NfAbsOrd{AnticNumberField,nf_elem},fmpz}"><code>Hecke.isindex_divisor</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isindex_divisor(O::NfOrd, d::fmpz) -&gt; Bool
isindex_divisor(O::NfOrd, d::Int) -&gt; Bool</code></pre><p>Returns whether <span>$d$</span> is a divisor of the index of <span>$\mathcal O$</span>. It is assumed that <span>$\mathcal O$</span> contains the equation order of the ambient number field.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Hecke.minkowski_matrix-Tuple{NfAbsOrd{AnticNumberField,nf_elem},Int64}" href="#Hecke.minkowski_matrix-Tuple{NfAbsOrd{AnticNumberField,nf_elem},Int64}"><code>Hecke.minkowski_matrix</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">minkowski_matrix(O::NfOrd, abs_tol::Int = 64) -&gt; arb_mat</code></pre><p>Returns the Minkowski matrix of <span>$\mathcal O$</span>.  Thus if <span>$\mathcal O$</span> has degree <span>$d$</span>, then the result is a matrix in <span>$\operatorname{Mat}_{d\times d}(\mathbf R)$</span>. The entries of the matrix are real balls of type <code>arb</code> with radius less then <code>2^-abs_tol</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.in-Tuple{nf_elem,NfAbsOrd{AnticNumberField,nf_elem}}" href="#Base.in-Tuple{nf_elem,NfAbsOrd{AnticNumberField,nf_elem}}"><code>Base.in</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">in(a::nf_elem, O::NfOrd) -&gt; Bool</code></pre><p>Checks whether <span>$a$</span> lies in <span>$\mathcal O$</span>.</p></div></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>denominator(::nf_elem, ::NfOrd)</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="Hecke.norm_change_const-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}" href="#Hecke.norm_change_const-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}"><code>Hecke.norm_change_const</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">norm_change_const(O::NfOrd) -&gt; (Float64, Float64)</code></pre><p>Returns <span>$(c_1, c_2) \in \mathbf R_{&gt;0}^2$</span> such that for all <span>$x = \sum_{i=1}^d x_i \omega_i \in \mathcal O$</span> we have <span>$T_2(x) \leq c_1 \cdot \sum_i^d x_i^2$</span> and <span>$\sum_i^d x_i^2 \leq c_2 \cdot T_2(x)$</span>, where <span>$(\omega_i)_i$</span> is the <span>$\mathbf Z$</span>-basis of <span>$\mathcal O$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Hecke.trace_matrix-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}" href="#Hecke.trace_matrix-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}"><code>Hecke.trace_matrix</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">trace_matrix(O::NfOrd) -&gt; fmpz_mat</code></pre><p>Returns the trace matrix of <span>$\mathcal O$</span>, that is, the matrix <span>$(\operatorname{tr}_{K/\mathbf Q}(b_i \cdot b_j))_{1 \leq i, j \leq d}$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:+-Tuple{NfAbsOrd{AnticNumberField,nf_elem},NfAbsOrd{AnticNumberField,nf_elem}}" href="#Base.:+-Tuple{NfAbsOrd{AnticNumberField,nf_elem},NfAbsOrd{AnticNumberField,nf_elem}}"><code>Base.:+</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">+(R::NfOrd, S::NfOrd) -&gt; NfOrd</code></pre><p>Given two orders <span>$R$</span>, <span>$S$</span> of <span>$K$</span>, this function returns the smallest order containing both <span>$R$</span> and <span>$S$</span>. It is assumed that <span>$R$</span>, <span>$S$</span> contain the ambient equation order and have coprime index.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Hecke.poverorder-Tuple{NfAbsOrd{AnticNumberField,nf_elem},fmpz}" href="#Hecke.poverorder-Tuple{NfAbsOrd{AnticNumberField,nf_elem},fmpz}"><code>Hecke.poverorder</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">poverorder(O::NfOrd, p::fmpz) -&gt; NfOrd
poverorder(O::NfOrd, p::Integer) -&gt; NfOrd</code></pre><p>This function tries to find an order that is locally larger than <span>$\mathcal O$</span> at the prime <span>$p$</span>: If <span>$p$</span> divides the index <span>$[ \mathcal O_K : \mathcal O]$</span>, this function will return an order <span>$R$</span> such that <span>$v_p([ \mathcal O_K : R]) &lt; v_p([ \mathcal O_K : \mathcal O])$</span>. Otherwise <span>$\mathcal O$</span> is returned.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Hecke.pmaximal_overorder-Tuple{NfAbsOrd{AnticNumberField,nf_elem},fmpz}" href="#Hecke.pmaximal_overorder-Tuple{NfAbsOrd{AnticNumberField,nf_elem},fmpz}"><code>Hecke.pmaximal_overorder</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pmaximal_overorder(O::NfOrd, p::fmpz) -&gt; NfOrd
pmaximal_overorder(O::NfOrd, p::Integer) -&gt; NfOrd</code></pre><p>This function finds a <span>$p$</span>-maximal order <span>$R$</span> containing <span>$\mathcal O$</span>. That is, the index <span>$[ \mathcal O_K : R]$</span> is not divisible by <span>$p$</span>.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../introduction/">Â« Introduction</a><a class="docs-footer-nextpage" href="../elements/">Elements Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 13 April 2021 13:06">Tuesday 13 April 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
