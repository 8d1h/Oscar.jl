<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Integers · Oscar.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Oscar.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Welcome to Oscar</a></li><li><span class="toctext">Rings</span><ul><li class="current"><a class="toctext" href="integer.html">Integers</a><ul class="internal"><li><a class="toctext" href="#Constructors-1">Constructors</a></li><li><a class="toctext" href="#Julia-integers-in-Oscar-functions-1">Julia integers in Oscar functions</a></li><li><a class="toctext" href="#Basic-functionality-1">Basic functionality</a></li><li><a class="toctext" href="#Basic-arithmetic-1">Basic arithmetic</a></li><li><a class="toctext" href="#integer_euclidean_division-1">Euclidean division</a></li><li><a class="toctext" href="#integer_divisibility_testing-1">Divisibility testing</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Rings</li><li><a href="integer.html">Integers</a></li></ul><a class="edit-page" href="https://github.com/oscar-system/Oscar.jl/blob/master/docs/src/integer.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Integers</span><a class="fa fa-bars" href="#"></a></div></header><div></div><ul><li><a href="integer.html#Integers-1">Integers</a></li><ul><li><a href="integer.html#Constructors-1">Constructors</a></li><li><a href="integer.html#Julia-integers-in-Oscar-functions-1">Julia integers in Oscar functions</a></li><li><a href="integer.html#Basic-functionality-1">Basic functionality</a></li><li><a href="integer.html#Basic-arithmetic-1">Basic arithmetic</a></li><li><a href="integer.html#integer_euclidean_division-1">Euclidean division</a></li><li><a href="integer.html#integer_divisibility_testing-1">Divisibility testing</a></li></ul></ul><h1><a class="nav-anchor" id="Integers-1" href="#Integers-1">Integers</a></h1><p>An important design decision in Oscar.jl is to use Julia as the user language by default. This means that integers typed at the <a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">REPL</a> are <a href="https://docs.julialang.org/en/v1/manual/integers-and-floating-point-numbers/">Julia integers</a>. However, for performance reasons, Oscar has its own integer format.</p><p>In the following, unless stated otherwise, when we refer to integers we mean Oscar integers; when we refer to an <code>Int</code> we mean the Julia <code>Int</code>.</p><h2><a class="nav-anchor" id="Constructors-1" href="#Constructors-1">Constructors</a></h2><p>Oscar integers are created using the <code>ZZ</code> constructor.</p><pre><code class="language-julia-repl">julia&gt; ZZ(2)^100
1267650600228229401496703205376

julia&gt; ZZ(618970019642690137449562111)
618970019642690137449562111</code></pre><h3><a class="nav-anchor" id="Limitations-1" href="#Limitations-1">Limitations</a></h3><p>Oscar integers have the same limitations as <a href="https://gmplib.org/">GMP</a> multiprecision integers, namely that they are limited by the available memory on the machine and in any case to signed integers whose absolute value does not exceed <span>$2^{37}$</span> bits.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>The Julia &#39;Int&#39; type is either a 32 or 64 bit integer, depending on the machine architecture (usually 64 bits on most modern machines). The range of values is machine dependent, but can be found by typing &#39;typemin(Int)&#39; and &#39;typemax(Int)&#39; in Julia.</p></div></div><h2><a class="nav-anchor" id="Julia-integers-in-Oscar-functions-1" href="#Julia-integers-in-Oscar-functions-1">Julia integers in Oscar functions</a></h2><p>For convenience, many Oscar functions also accept Julia integers. For example:</p><pre><code class="language-julia-repl">julia&gt; divexact(ZZ(234), 2)
117</code></pre><p>In this example, <code>2</code> is a Julia integer but is still valid in the call to the Oscar function <code>divexact</code>.</p><p>In general, Oscar can only automatically convert from Julia integers to Oscar integers if they are combined with other Oscar objects or passed to Oscar functions.</p><h2><a class="nav-anchor" id="Basic-functionality-1" href="#Basic-functionality-1">Basic functionality</a></h2><p>Oscar provides the following basic functions for the ring of integers:</p><ul><li><code>zero(ZZ)</code> - return the integer 0</li><li><code>one(ZZ)</code> - return the integer 1</li></ul><p>There are also the following predicates for integers <code>n</code> which return <code>true</code> or <code>false</code>:</p><ul><li><code>iszero(n)</code> - <span>$n = 0$</span></li><li><code>isone(n)</code> - <span>$n = 1$</span></li><li><code>isunit(n)</code> - <span>$n = \pm 1$</span></li></ul><p>The following functions are also provided.</p><ul><li><code>sign(n)</code> returns the sign of <code>n</code>, i.e. <span>$n/|n|$</span> if <span>$n \neq 0$</span> or <span>$0$</span> otherwise.</li></ul><pre><code class="language-julia-repl">julia&gt; sign(ZZ(23))
1

julia&gt; sign(ZZ(0))
0

julia&gt; sign(ZZ(-1))
-1</code></pre><h2><a class="nav-anchor" id="Basic-arithmetic-1" href="#Basic-arithmetic-1">Basic arithmetic</a></h2><p>Oscar provides the basic arithmetic operations <code>+</code>, <code>-</code> and <code>*</code> and comparison operators <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, including mixed operations between Julia and Oscar integers. It also provides division and powering as described below.</p><h3><a class="nav-anchor" id="Division-in-Oscar-1" href="#Division-in-Oscar-1">Division in Oscar</a></h3><p>Oscar distinguishes a number of different kinds of division:</p><ul><li><a href="integer.html#integer_exact_division-1">Exact division</a> (<code>divexact</code>)</li><li><a href="integer.html#integer_euclidean_division-1">Euclidean division</a> (<code>div</code>, <code>divrem</code>, <code>mod</code>, <code>rem</code>)</li><li>Construction of fractions (<code>a//b</code>)</li><li>Floating point division (<code>a/b</code>)</li><li><a href="integer.html#integer_divisibility_testing-1">Divisibility testing</a> (<code>divides</code>)</li></ul><p>These choices have been made for maximum parsimony with the Julia language.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>It is a common error to enter &#39;1/2&#39; for the fraction &#39;one half&#39; in Julia. This expression is reserved for floating point division. Instead, the double slash operator &#39;//&#39; should be used for fractions.</p></div></div><h3><a class="nav-anchor" id="integer_exact_division-1" href="#integer_exact_division-1">Exact Division</a></h3><p>Exact division is carried out using the <code>divexact</code> function.</p><p>The result of the exact division of two integers will always be another integer. Exact division raises an exception if the division is not exact, or if division by zero is attempted.</p><pre><code class="language-julia-repl">julia&gt; divexact(ZZ(6), ZZ(3))
2

julia&gt; divexact(ZZ(6), ZZ(0))
ERROR: DivideError: integer division error

julia&gt; divexact(ZZ(6), ZZ(5))
1</code></pre><h3><a class="nav-anchor" id="Powering-1" href="#Powering-1">Powering</a></h3><p>Powering of integers is performed using the caret operator <code>^</code>. The exponent can be any Julia <code>Int</code>.</p><pre><code class="language-julia-repl">julia&gt; ZZ(37)^37
10555134955777783414078330085995832946127396083370199442517

julia&gt; ZZ(1)^(-2)
1</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>An exception will be raised if an integer outside the range [-1, 1] is raised to a negative exponent.</p></div></div><p>The following is allowed for convenience.</p><pre><code class="language-julia-repl">julia&gt; ZZ(0)^0
1</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>In Julia, &#39;2^64&#39; will return 0, as the Julia integer 2 is a machine word. In Oscar, the expression &#39;ZZ(2)^64&#39; will return the expected result.</p></div></div><h2><a class="nav-anchor" id="integer_euclidean_division-1" href="#integer_euclidean_division-1">Euclidean division</a></h2><p>The ring of integers is a Euclidean domain and Oscar provides Euclidean division.</p><p>The <code>divrem</code> function returns both quotient and remainder, whilst <code>div</code> returns just the quotient and <code>mod</code> returns just the remainder.</p><p>The remainder is taken to be the least non-negative residue, i.e. if <span>$a$</span> and <span>$m$</span> are integers, Euclidean division in Oscar finds a quotient <span>$q$</span> and remainder <span>$r$</span> such that <span>$a = q|m| + r$</span> where <span>$0 \leq r &lt; |m|$</span>.</p><pre><code class="language-julia-repl">julia&gt; q, r = divrem(ZZ(5), ZZ(-3))
(-1, 2)</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>The results of <code>divrem</code>, <code>div</code> and <code>mod</code> do not agree with their namesakes in Julia when the modulus <span>$m$</span> is negative.</p></div></div><h2><a class="nav-anchor" id="integer_divisibility_testing-1" href="#integer_divisibility_testing-1">Divisibility testing</a></h2><p>Divisibility testing is performed using the <code>divides</code> function.</p><p>In Oscar, we say that <span>$b$</span> divides <span>$a$</span> if there exists <span>$c$</span> in the same ring such that <span>$a = bc$</span>.</p><p>The call <code>divides(a, b)</code> returns a tuple <code>(flag, q)</code> where <code>flag</code> is either <code>true</code> if <code>b</code> divides <code>a</code> in which case <code>q</code> will be a quotient, or <code>flag</code> is <code>false</code> if <code>b</code> does not divide <code>a</code> and <code>q</code> will be an integer whose value is not defined.</p><pre><code class="language-julia-repl">julia&gt; divides(ZZ(6), ZZ(3))
(true, 2)

julia&gt; divides(ZZ(5), ZZ(2))
(false, 2)</code></pre><p>Note that for convenience we define:</p><pre><code class="language-julia-repl">julia&gt; divides(ZZ(0), ZZ(0))
ERROR: DivideError: integer division error</code></pre><footer><hr/><a class="previous" href="index.html"><span class="direction">Previous</span><span class="title">Welcome to Oscar</span></a></footer></article></body></html>
