<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Integers · Oscar.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Oscar.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Welcome to Oscar</a></li><li><span class="toctext">Rings</span><ul><li class="current"><a class="toctext" href="integer.html">Integers</a><ul class="internal"><li><a class="toctext" href="#The-ring-of-integers-1">The ring of integers</a></li><li><a class="toctext" href="#Julia-integers-in-Oscar-functions-1">Julia integers in Oscar functions</a></li><li><a class="toctext" href="#Predicates-and-properties-1">Predicates and properties</a></li><li><a class="toctext" href="#Basic-arithmetic-1">Basic arithmetic</a></li><li><a class="toctext" href="#integer_euclidean_division-1">Euclidean division</a></li><li><a class="toctext" href="#integer_divisibility_testing-1">Divisibility testing</a></li><li><a class="toctext" href="#Gcd-and-lcm-1">Gcd and lcm</a></li><li><a class="toctext" href="#Roots-1">Roots</a></li><li><a class="toctext" href="#Conversions-1">Conversions</a></li><li><a class="toctext" href="#Factorisation-1">Factorisation</a></li><li><a class="toctext" href="#Combinatorial-functions-1">Combinatorial functions</a></li><li><a class="toctext" href="#Number-theoretic-functionality-1">Number theoretic functionality</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Rings</li><li><a href="integer.html">Integers</a></li></ul><a class="edit-page" href="https://github.com/oscar-system/Oscar.jl/blob/master/docs/src/integer.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Integers</span><a class="fa fa-bars" href="#"></a></div></header><div></div><ul><li><a href="integer.html#Integers-1">Integers</a></li><ul><li><a href="integer.html#The-ring-of-integers-1">The ring of integers</a></li><li><a href="integer.html#Julia-integers-in-Oscar-functions-1">Julia integers in Oscar functions</a></li><li><a href="integer.html#Predicates-and-properties-1">Predicates and properties</a></li><li><a href="integer.html#Basic-arithmetic-1">Basic arithmetic</a></li><li><a href="integer.html#integer_euclidean_division-1">Euclidean division</a></li><li><a href="integer.html#integer_divisibility_testing-1">Divisibility testing</a></li><li><a href="integer.html#Gcd-and-lcm-1">Gcd and lcm</a></li><li><a href="integer.html#Roots-1">Roots</a></li><li><a href="integer.html#Conversions-1">Conversions</a></li><li><a href="integer.html#Factorisation-1">Factorisation</a></li><li><a href="integer.html#Combinatorial-functions-1">Combinatorial functions</a></li><li><a href="integer.html#Number-theoretic-functionality-1">Number theoretic functionality</a></li></ul></ul><h1><a class="nav-anchor" id="Integers-1" href="#Integers-1">Integers</a></h1><p>An important design decision in Oscar.jl is to use Julia as the user language by default. This means that integers typed at the <a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">REPL</a> are <a href="https://docs.julialang.org/en/v1/manual/integers-and-floating-point-numbers/">Julia integers</a>. However, for performance reasons, Oscar has its own integer format.</p><p>In the following, unless stated otherwise, when we refer to integers we mean Oscar integers; when we refer to an <code>Int</code> we mean the Julia <code>Int</code>.</p><h2><a class="nav-anchor" id="The-ring-of-integers-1" href="#The-ring-of-integers-1">The ring of integers</a></h2><p>Every object in Oscar representing a mathematical element has a parent. This is an object encoding information about where that element belongs.</p><p>The parent of an Oscar integer is the ring of integers <code>ZZ</code>.</p><pre><code class="language-julia-repl">julia&gt; ZZ
Integer Ring

julia&gt; R = parent(ZZ(2))
Integer Ring

julia&gt; R == ZZ
true</code></pre><h3><a class="nav-anchor" id="Integer-constructors-1" href="#Integer-constructors-1">Integer constructors</a></h3><p>Oscar integers are created using <code>ZZ</code>:</p><pre><code class="language-julia-repl">julia&gt; ZZ(2)^100
1267650600228229401496703205376

julia&gt; ZZ(618970019642690137449562111)
618970019642690137449562111</code></pre><p>One can also construct the integer <span>$0$</span> with the empty constructor:</p><pre><code class="language-julia-repl">julia&gt; ZZ()
0</code></pre><p>The following special constructors are also provided:</p><ul><li><code>zero(ZZ)</code> : the integer 0</li><li><code>one(ZZ)</code> : the integer 1</li></ul><h3><a class="nav-anchor" id="Limitations-1" href="#Limitations-1">Limitations</a></h3><p>Oscar integers have the same limitations as <a href="https://gmplib.org/">GMP</a> multiprecision integers, namely that they are limited by the available memory on the machine and in any case to signed integers whose absolute value does not exceed <span>$2^{37}$</span> bits.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>The Julia <code>Int</code> type is either a 32 or 64 bit integer, depending on the machine architecture (usually 64 bits on most modern machines). The range of values is machine dependent, but can be found by typing <code>typemin(Int)</code> and <code>typemax(Int)</code> in Julia.</p></div></div><h2><a class="nav-anchor" id="Julia-integers-in-Oscar-functions-1" href="#Julia-integers-in-Oscar-functions-1">Julia integers in Oscar functions</a></h2><p>For convenience, basic arithmetic and exact division functions in Oscar also accept Julia integers. For example:</p><pre><code class="language-julia-repl">julia&gt; divexact(ZZ(234), 2)
117</code></pre><p>In this example, <code>2</code> is a Julia integer but is still valid in the call to the Oscar function <code>divexact</code>.</p><p>A number of other integer functions also accept Julia <code>Int</code>&#39;s, as noted below.</p><h2><a class="nav-anchor" id="Predicates-and-properties-1" href="#Predicates-and-properties-1">Predicates and properties</a></h2><p>The following predicates are provided, which return <code>true</code> or <code>false</code>:</p><ul><li><code>iszero(n)</code> : <span>$n = 0$</span></li><li><code>isone(n)</code> : <span>$n = 1$</span></li><li><code>isunit(n)</code> : <span>$n = \pm 1$</span></li><li><code>issquare(n)</code></li><li><code>isprime(n)</code></li><li><code>isprobable_prime(n)</code></li></ul><p>The <code>isprime</code> predicate will prove primality, whereas <code>isprobable_prime</code> may declare a composite number to be prime with very low probability.</p><p>Negative numbers, <span>$0$</span> and <span>$1$</span> are not considered prime by these predicates.</p><p>The following properties can also be computed:</p><ul><li><code>sign(n)</code> returns the sign of <code>n</code>, i.e. <span>$n/|n|$</span> if <span>$n \neq 0$</span> or <span>$0$</span> otherwise. The return value is a Julia <code>Int</code>.</li></ul><pre><code class="language-julia-repl">julia&gt; sign(ZZ(23))
1

julia&gt; sign(ZZ(0))
0

julia&gt; sign(ZZ(-1))
-1</code></pre><h2><a class="nav-anchor" id="Basic-arithmetic-1" href="#Basic-arithmetic-1">Basic arithmetic</a></h2><p>Oscar provides the basic arithmetic operations <code>+</code>, <code>-</code> and <code>*</code> and comparison operators <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, including mixed operations between Julia and Oscar integers. It also provides division and powering as described below.</p><h3><a class="nav-anchor" id="Division-in-Oscar-1" href="#Division-in-Oscar-1">Division in Oscar</a></h3><p>Oscar distinguishes a number of different kinds of division:</p><ul><li><a href="integer.html#integer_exact_division-1">Exact division</a> (<code>divexact</code>)</li><li><a href="integer.html#integer_euclidean_division-1">Euclidean division</a> (<code>div</code>, <code>rem</code>, <code>divrem</code> and <code>mod</code>)</li><li>Construction of fractions (<code>a//b</code>)</li><li>Floating point division (<code>a/b</code>)</li><li><a href="integer.html#integer_divisibility_testing-1">Divisibility testing</a> (<code>divides</code>)</li></ul><p>These choices have been made for maximum parsimony with the Julia language.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>It is a common error to enter <code>1/2</code> for the fraction &#39;one half&#39; in Julia. This expression is reserved for floating point division. Instead, the double slash operator <code>//</code> should be used for fractions.</p></div></div><h3><a class="nav-anchor" id="integer_exact_division-1" href="#integer_exact_division-1">Exact Division</a></h3><p>Exact division is carried out using the <code>divexact</code> function.</p><p>The result of the exact division of two integers will always be another integer. Exact division raises an exception if the division is not exact, or if division by zero is attempted.</p><pre><code class="language-julia-repl">julia&gt; divexact(ZZ(6), ZZ(3))
2

julia&gt; divexact(ZZ(6), ZZ(0))
ERROR: DivideError: integer division error

julia&gt; divexact(ZZ(6), ZZ(5))
1</code></pre><h3><a class="nav-anchor" id="Powering-1" href="#Powering-1">Powering</a></h3><p>Powering of integers is performed using the caret operator <code>^</code>. The exponent can be any Julia <code>Int</code>.</p><pre><code class="language-julia-repl">julia&gt; ZZ(37)^37
10555134955777783414078330085995832946127396083370199442517

julia&gt; ZZ(1)^(-2)
1</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>An exception will be raised if an integer other than <span>$-1$</span> or <span>$1$</span> is raised to a negative exponent.</p></div></div><p>The following is allowed for convenience.</p><pre><code class="language-julia-repl">julia&gt; ZZ(0)^0
1</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>In Julia, <code>2^64</code> will return zero, as the Julia integer <span>$2$</span> is a machine word. In Oscar, the expression <code>ZZ(2)^64</code> will return the expected result.</p></div></div><h2><a class="nav-anchor" id="integer_euclidean_division-1" href="#integer_euclidean_division-1">Euclidean division</a></h2><p>The ring of integers is a Euclidean domain and Oscar provides Euclidean division.</p><p>In a Euclidean domain in Oscar the <code>divrem</code> function returns both quotient and remainder, <code>div</code> returns just the quotient and <code>rem</code> returns just the remainder.</p><p>For integers, Euclidean division of <span>$a$</span> by <span>$n$</span> computes a quotient and remainder such that</p><pre><code class="language-">a = qn + r</code></pre><p>where <span>$|r| &lt; |n|$</span>. For conformity with Julia, when <span>$r \neq 0$</span> the sign of <span>$r$</span> will be the same as the sign of <span>$a$</span>.</p><p>If one instead wants Euclidean remainder with <span>$r$</span> and <span>$n$</span> having the same sign, one can use <code>mod</code>. Then if <span>$n &gt; 0$</span> the remainder will be non-negative.</p><table><tr><th>remainder</th><th>division</th><th>sign</th><th>rounding</th></tr><tr><td>rem</td><td>div/divrem</td><td>same as dividend</td><td>towards zero</td></tr><tr><td>mod</td><td></td><td>same as divisor</td><td>towards <span>$-\infty$</span></td></tr></table><pre><code class="language-julia-repl">julia&gt; q, r = divrem(ZZ(5), ZZ(3))
(1, 2)

julia&gt; q = div(ZZ(7), ZZ(2))
3

julia&gt; r = mod(ZZ(4), ZZ(3))
1</code></pre><p>All three functions raise an exception if the modulus <span>$m$</span> is zero.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>The rem function does not provide a minimal set of representatives, e.g. <code>rem(-2, 3) = -2</code> but <code>rem(1, 3) = 1</code>.</p></div></div><p>All integer Euclidean division functions accept a Julia <code>Int</code> for one of their arguments.</p><h2><a class="nav-anchor" id="integer_divisibility_testing-1" href="#integer_divisibility_testing-1">Divisibility testing</a></h2><p>Divisibility testing is performed using the <code>divides</code> function.</p><p>In Oscar, we say that <span>$b$</span> divides <span>$a$</span> if there exists <span>$c$</span> in the same ring such that <span>$a = bc$</span>.</p><p>The call <code>divides(a, b)</code> returns a tuple <code>(flag, q)</code> where <code>flag</code> is either <code>true</code> if <code>b</code> divides <code>a</code> in which case <code>q</code> will be a quotient, or <code>flag</code> is <code>false</code> if <code>b</code> does not divide <code>a</code> and <code>q</code> will be an integer whose value is not defined.</p><pre><code class="language-julia-repl">julia&gt; divides(ZZ(6), ZZ(3))
(true, 2)

julia&gt; divides(ZZ(5), ZZ(2))
(false, 2)</code></pre><p>Note that for convenience we define:</p><pre><code class="language-julia-repl">julia&gt; divides(ZZ(0), ZZ(0))
ERROR: DivideError: integer division error</code></pre><h2><a class="nav-anchor" id="Gcd-and-lcm-1" href="#Gcd-and-lcm-1">Gcd and lcm</a></h2><p>The <code>gcd</code> function returns the greatest common divisor of its inputs, which is by definition the largest integer dividing the two inputs unless both inputs are zero in which case it returns zero. The result will always be non-negative and will only be zero if both inputs are zero.</p><pre><code class="language-julia-repl">julia&gt; gcd(ZZ(34), ZZ(17))
17

julia&gt; gcd(ZZ(3), ZZ(0))
3</code></pre><p>The <code>lcm</code> function returns the least positive multiple of its inputs, unless one or more of its inputs is zero, in which case it returns zero.</p><pre><code class="language-julia-repl">julia&gt; lcm(ZZ(6), ZZ(21))
42

julia&gt; lcm(ZZ(0), ZZ(0))
0</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>The identity <span>$\gcd(m, n)\mathrm{lcm}(m, n) = mn$</span> does not hold for the definition that Oscar uses, unless both <span>$m$</span> and <span>$n$</span> are the same sign or one of them is zero.</p></div></div><p>Both <code>gcd</code> and <code>lcm</code> accept Julia <code>Int</code>&#39;s for one of their arguments.</p><h2><a class="nav-anchor" id="Roots-1" href="#Roots-1">Roots</a></h2><p>Julia and Oscar distinguish two kinds of square root:</p><ul><li>Integer square root (<code>isqrt</code>)</li><li>Floating point square root (<code>sqrt</code>)</li></ul><p>The <code>isqrt</code> function returns the floor of the square root of its argument, i.e. the largest integer whose square does not exceed its input. An exception is raised if a negative input is passed.</p><pre><code class="language-julia-repl">julia&gt; isqrt(ZZ(16))
4

julia&gt; isqrt(ZZ(0))
0

julia&gt; isqrt(ZZ(5))
2

julia&gt; isqrt(ZZ(-3))
ERROR: DomainError with Argument must be non-negative: -3:</code></pre><p>If the remainder is also required, there is the <code>isqrtrem</code> function. It returns a tuple <code>(s, r)</code> such that <span>$s$</span> is the same as the return value of the <code>isqrt</code> function and <span>$s^2 + r$</span> is equal to the input.</p><pre><code class="language-julia-repl">julia&gt; isqrtrem(ZZ(16))
(4, 0)

julia&gt; isqrtrem(ZZ(5))
(2, 1)</code></pre><p>The function <code>root(a, n)</code> will return the value of largest absolute value whose <span>$n$</span>-th power does not exceed <span>$a$</span>. When <span>$n$</span> is even, <span>$a$</span> must be non-negative and the return value will always be non-negative. The value of <span>$a$</span> may be negative if <span>$n$</span> is negative. The value <span>$n$</span> must always be a positive Julia <code>Int</code>.</p><pre><code class="language-julia-repl">julia&gt; root(ZZ(16), 4)
2

julia&gt; root(ZZ(5), 2)
2

julia&gt; root(ZZ(-5), 3)
-1

julia&gt; root(ZZ(0), 4)
0

julia&gt; root(ZZ(-5), 2)
ERROR: DomainError with Argument -5 must be positive if exponent 2 is even:

julia&gt; root(ZZ(12), -2)
ERROR: DomainError with Exponent must be non-negative: -2:</code></pre><h2><a class="nav-anchor" id="Conversions-1" href="#Conversions-1">Conversions</a></h2><p>Oscar integers can be converted to Julia <code>Int</code>&#39;s and <code>BigInt</code>&#39;s in the usual Julia way:</p><pre><code class="language-julia-repl">julia&gt; n = ZZ(123)
123

julia&gt; Int(n)
123

julia&gt; BigInt(n)
123</code></pre><p>If the Oscar integer is too large to fit in an <code>Int</code>, an exception is raised.</p><pre><code class="language-julia-repl">julia&gt; Int(ZZ(12348732648732648763274868732687324))
ERROR: MethodError: no method matching InexactError()
Closest candidates are:
  InexactError(!Matched::Symbol, !Matched::Any, !Matched::Any) at boot.jl:269</code></pre><p>The <code>fits</code> function can be used to determine whether an Oscar integer will fit in a Julia <code>Int</code>:</p><pre><code class="language-julia-repl">julia&gt; fits(Int, ZZ(12348732648732648763274868732687324))
false</code></pre><h2><a class="nav-anchor" id="Factorisation-1" href="#Factorisation-1">Factorisation</a></h2><p>Factorisation of nonzero integers is provided by the <code>factor</code> function.</p><pre><code class="language-julia-repl">julia&gt; factor(ZZ(-6000361807272228723606))
-1 * 2 * 229^3 * 43669^3 * 3

julia&gt; factor(ZZ(0))
ERROR: ArgumentError: Argument is not non-zero</code></pre><p>The unit (<span>$\pm 1$</span>) can be accessed via the <code>unit</code> function:</p><pre><code class="language-julia-repl">julia&gt; F = factor(ZZ(-12))
-1 * 2^2 * 3

julia&gt; unit(F)
-1</code></pre><p>Once created, a factorisation is iterable:</p><pre><code class="language-julia-repl">julia&gt; F = factor(ZZ(-60))
-1 * 5 * 2^2 * 3

julia&gt; for (p, e) in F; println(&quot;$p^$e&quot;); end
5^1
2^2
3^1</code></pre><p>The pairs <code>(p, e)</code> in a factorisation represent the prime power factors <span>$p^e$</span> of the non-unit part of the factorisation. They can be placed in an array using <code>collect</code>:</p><pre><code class="language-julia-repl">julia&gt; F = factor(ZZ(-60))
-1 * 5 * 2^2 * 3

julia&gt; collect(F)
3-element Array{Pair{Nemo.fmpz,Int64},1}:
 5 =&gt; 1
 2 =&gt; 2
 3 =&gt; 1</code></pre><p>One can also determine whether a given prime is in the non-unit part of a factorisation and if so return its exponent. If the exponent of a prime that is not in a factorisation is requested, an exception is raised.</p><p>For convenience, a Julia <code>Int</code> can be used instead of an Oscar integer for this functionality.</p><pre><code class="language-julia-repl">julia&gt; F = factor(ZZ(-60))
-1 * 5 * 2^2 * 3

julia&gt; 5 in F
true

julia&gt; ZZ(3) in F
true

julia&gt; 7 in F
false

julia&gt; F[3]
1

julia&gt; F[ZZ(7)]
ERROR: 7 is not a factor of -1 * 5 * 2^2 * 3</code></pre><h2><a class="nav-anchor" id="Combinatorial-functions-1" href="#Combinatorial-functions-1">Combinatorial functions</a></h2><ul><li><code>Oscar.factorial(n)</code></li></ul><p>Returns the factorial of <span>$n$</span>, i.e. <span>$n!$</span>. Here <span>$n$</span> should be a Julia <code>Int</code>. The return value is an Oscar integer. An exception is raised if <span>$n &lt; 0$</span>. We define <span>$0! = 1$</span>.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>The function <code>factorial</code> is already defined in Julia, but returns a Julia <code>Int</code>, which overflows when the result is too large. To disambiguate the Oscar version of the function it is accessed via <code>Oscar.factorial</code>.</p></div></div><ul><li><code>rising_factorial(x, n)</code></li></ul><p>Returns <span>$x(x + 1)(x + 2)\ldots(x + n - 1)$</span>. The value <span>$x$</span> can be an Oscar integer or a Julia integer, but <span>$n$</span> must be a Julia <code>Int</code>. An exception is raised if <span>$n &lt; 0$</span>. We define <code>rising_factorial(x, 0)</code> to be <span>$1$</span>.</p><ul><li><code>primorial(n)</code></li></ul><p>Returns the <span>$n$</span>-th primorial number <span>$P(n)$</span>, i.e. the product of all primes less than or equal to <span>$n$</span>. An exception is raised if <span>$n &lt; 0$</span>. We define <span>$P(0) = P(1) = 1$</span>. The value <span>$n$</span> must be a Julia <code>Int</code>.</p><ul><li><code>bell(n)</code></li></ul><p>Returns the <span>$n$</span>-th Bell number <span>$B(n)$</span>, i.e. the number of ways of partitioning a set of <span>$n$</span> elements. An exception is raised if <span>$n &lt; 0$</span>. The value <span>$n$</span> must be a Julia <code>Int</code>.</p><ul><li><code>Oscar.binomial(n, k)</code></li></ul><p>Returns the binomial coefficient <span>$\frac{n!}{k!(n - k)!}$</span>. If <span>$n, k &lt; 0$</span> or <span>$k &gt; n$</span> we return zero. Both <span>$n$</span> and <span>$k$</span> must be Julia <code>Int</code>&#39;s.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Julia already defines the <code>binomial</code> function,  which returns an <code>Int</code> that may overflow when the result is too large. To disambiguate the Oscar version of the function it is accessed via <code>Oscar.binomial</code>.</p></div></div><ul><li><code>number_of_partitions(n)</code></li></ul><p>Returns the number of integer partitions <span>$p(n)$</span> of <span>$n$</span>, i.e. the number of distinct ways to write <span>$n$</span> as a sum of positive integers. Note that <span>$p(0) = 1, as the empty sum is counted. For$</span>n &lt; 0<span>$we return zero. The argument$</span>n`` can be a Julia integer or an Oscar integer and the result is an Oscar integer.</p><h2><a class="nav-anchor" id="Number-theoretic-functionality-1" href="#Number-theoretic-functionality-1">Number theoretic functionality</a></h2><ul><li><code>fibonacci(n)</code></li></ul><p>Returns the <span>$n$</span>-th Fibonacci number <span>$F(n)$</span>, defined by the recurrence relation <span>$F(1) = 1$</span>, <span>$F(2) = 1$</span> and <span>$F(n) = F(n - 1) + F(n - 2)$</span> for <span>$n \geq 3$</span>. For convenience we define <span>$F(0) = 0$</span>. An exception is raised if <span>$n &lt; 0$</span>. The value <span>$n$</span> must be a Julia <code>Int</code>.</p><ul><li><code>moebius_mu(n)</code></li></ul><p>Return the Moebius function <span>$\mu(n)$</span>, which is defined to be <span>$0$</span> if <span>$n$</span> is not squarefree and otherwise is defined to be <span>$+1$</span> or <span>$-1$</span> if <span>$n$</span> has an even or odd number of prime factors, respectively. Alternatively, <span>$\mu(n)$</span> can be defined to be the sum of the primitive <span>$n$</span>-th roots of unity.  The parameter <span>$n$</span> can be a Julia integer or an Oscar integer. The result will be a Julia <code>Int</code>. An exception is raised if <span>$n &lt; 0$</span>.</p><ul><li><code>jacobi_symbol(m, n)</code></li></ul><p>Return the Jacobi symbol <span>$\left(\frac{m}{n}\right)$</span>, which is defined for integers <span>$m$</span> and odd positive integers <span>$n$</span>. If the factorisation of <span>$n$</span> is <span>$n = p_1^{i_1}p_2^{i_2}\ldots p_r^{i_r}$</span> then we define</p><div>\[\left(\frac{m}{n}\right) = \left(\frac{m}{p_1}\right)^{i_1}\left(\frac{m}{p_2}\right)^{i_2}\ldots \left(\frac{m}{p_r}\right)^{i_r}\]</div><p>where <span>$\left(\frac{m}{p}\right)$</span> on the right hand side is the Legendre symbol, which is defined for an odd prime number <span>$p$</span> to be <span>$0$</span> if <span>$p$</span> divides <span>$m$</span> and otherwise <span>$+1$</span> or <span>$-1$</span> depending on whether <span>$m$</span> is a square modulo <span>$p$</span> or not. An exception is raised if <span>$n$</span> is even or not positive. The values <span>$m$</span> and <span>$n$</span> can either both be Julia integers or both Oscar integers. The result is a Julia <code>Int</code>.</p><ul><li><code>divisor_sigma(m, n)</code></li></ul><p>Return the sum of the <span>$n$</span>-th powers of the divisors of <span>$m$</span></p><div>\[\sigma(m, n) = \sum_{d\;|\;m} d^n.\]</div><p>We define <span>$\sigma(0, n) = 0$</span> for all <span>$n$</span>. If <span>$n &lt; 0$</span> we raise an exception. The value <span>$m$</span> can be a Julia integer or an Oscar integer. The return value is an Oscar integer.</p><ul><li><code>euler_phi(n)</code></li></ul><p>Return the Euler totient function <span>$\varphi(n)$</span>, i.e. the number of positive integers <span>$1 \leq x \leq n$</span> which are coprime to <span>$n$</span>. Note that <span>$\varphi(1) = 1$</span> and <span>$\varphi(0) = 0$</span>. We raise an exception if <span>$n &lt; 0$</span>. The argument <span>$n$</span> may be an Oscar integer or a Julia integer. The result is an Oscar integer.</p><footer><hr/><a class="previous" href="index.html"><span class="direction">Previous</span><span class="title">Welcome to Oscar</span></a></footer></article></body></html>
