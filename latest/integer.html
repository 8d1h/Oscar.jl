<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Integers · Oscar.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Oscar.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Welcome to Oscar</a></li><li><span class="toctext">Rings</span><ul><li class="current"><a class="toctext" href="integer.html">Integers</a><ul class="internal"><li><a class="toctext" href="#Basic-arithmetic-1">Basic arithmetic</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Rings</li><li><a href="integer.html">Integers</a></li></ul><a class="edit-page" href="https://github.com/oscar-system/Oscar.jl/blob/master/docs/src/integer.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Integers</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Integers-1" href="#Integers-1">Integers</a></h1><p>An important design decision in Oscar.jl is to use Julia as the user language by default. This means that integers typed at the <a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">REPL</a> are Julia integers.</p><p>For performance reasons, Oscar has its own integer format. These are entered using the <code>ZZ</code> constructor.</p><pre><code class="language-julia-repl">julia&gt; a = ZZ(2)^100
ERROR: UndefVarError: ZZ not defined</code></pre><p>For convenience, many Oscar functions also accept Julia integers as inputs by converting them to Oscar integers, especially if they do not fit in a machine word. For example:</p><pre><code class="language-julia-repl">julia&gt; R, x = ZZ[&quot;x&quot;] # create a polynomial ring over the integers
ERROR: UndefVarError: ZZ not defined

julia&gt; f = 2x
ERROR: UndefVarError: x not defined</code></pre><p>In this example, <code>2</code> is a Julia integer but is still valid in the call to the Oscar polynomial multiplication function that is implicit in the expression <code>2x</code>.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"></div></div><pre><code class="language-none">In Julia, `2^64` will return `0`, as the Julia integer `2` is a machine
word. In Oscar, the expression `ZZ(2)^64` will return the expected
result (and as an Oscar integer). In general, Oscar can only do an
automatic conversion to an Oscar integer if the Julia integer is
combined with another Oscar expression, or passed to an Oscar function.</code></pre><p>In the following, unless stated otherwise, when we refer to integers, we mean Oscar integers. When we refer to an <code>Int</code> we mean the Julia <code>Int</code>.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"></div></div><pre><code class="language-none">The Julia `Int` type is either a 32 or 64 bit integer, depending on
the machine architecture (usually 64 bits on most modern machines). The
range of values is machine dependent, but can be found by typing
`typemin(Int)` and `typemax(Int)` in Julia.</code></pre><p>Oscar integers have the same limitations as <a href="https://gmplib.org/">GMP</a> multiprecision integers, namely that they are limited by the available memory on the machine and in any case to signed integers whose absolute value does not exceed <span>$2^{37}$</span> binary bits.</p><h2><a class="nav-anchor" id="Basic-arithmetic-1" href="#Basic-arithmetic-1">Basic arithmetic</a></h2><p>Oscar provides the basic arithmetic operations <code>+</code>, <code>-</code> and <code>*</code> for integers.</p><h3><a class="nav-anchor" id="Division-1" href="#Division-1">Division</a></h3><p>Oscar distinguishes a number of different kinds of division:</p><ul><li>Exact division (<code>divexact</code>)</li><li>Euclidean division (<code>div</code>, <code>divrem</code>, <code>rem</code>)</li><li>Construction of fractions (<code>a//b</code>)</li><li>Floating point division (<code>a/b</code>)</li><li>Reciprocals (<code>inv</code>)</li><li>Divisibility testing (<code>divides</code>)</li></ul><p>These choices have been made for maximum parsimony with the Julia language.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"></div></div><pre><code class="language-none">It is a common error to enter `1/2` for the fraction one half in Julia.
In the Julia language, this expression is reserved for floating point
division. Instead, the double slash operator is used for fractions.</code></pre><p>Here we discuss only exact division and inversion/reciprocals. Euclidean division and divisibility testing are discussed below, floating point division is not defined for Oscar integers to avoid confusion, and fractions are discussed on the page for rational numbers.</p><p>The result of the exact division of two integers will always be another integer. Exact division raises an exception if the division is not exact, or if division by zero is attempted.</p><pre><code class="language-julia-repl">julia&gt; divexact(ZZ(6), ZZ(3))
ERROR: UndefVarError: ZZ not defined

julia&gt; divexact(ZZ(6), ZZ(0))
ERROR: UndefVarError: ZZ not defined

julia&gt; divexact(ZZ(6), ZZ(5))
ERROR: UndefVarError: ZZ not defined</code></pre><h3><a class="nav-anchor" id="Powering-1" href="#Powering-1">Powering</a></h3><p>Powering of integers is performed using the caret operator <code>^</code>. The exponent can be any Julia <code>Int</code>.</p><pre><code class="language-julia-repl">julia&gt; ZZ(37)^37
ERROR: UndefVarError: ZZ not defined

julia&gt; ZZ(1)^(-2)
ERROR: UndefVarError: ZZ not defined</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"></div></div><pre><code class="language-none">An exception will be raised if an integer outside the range
    ``[-1, 1]`` is raised to a negative exponent.</code></pre><p>The following is allowed for convenience.</p><pre><code class="language-julia-repl">julia&gt; ZZ(0)^0
ERROR: UndefVarError: ZZ not defined</code></pre><footer><hr/><a class="previous" href="index.html"><span class="direction">Previous</span><span class="title">Welcome to Oscar</span></a></footer></article></body></html>
